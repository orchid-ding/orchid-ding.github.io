<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="天行健、君子以自强不息；地势坤，君子以厚德载物。">
    <meta name="keyword"  content="兰草">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        scala学习入门 - kfly的博客 | kfly&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1598291_q3el2wqimj.css" type="text/css">
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 君子谦谦，温和有礼，有才而不骄，得志而不傲，居于谷而不卑。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>kfly</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont iconhome"></i>
                    <span>主页</span>
                </a>
            </li>
 	   <li >
                <a href="/spec/">
                    <i class="iconfont iconzhuanti"></i>
                    <span>专题</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>简历</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-scala简介"><span class="toc-text">1. scala简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-为什么用scala"><span class="toc-text">2. 为什么用scala</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-开发环境安装"><span class="toc-text">3. 开发环境安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-scala中声明变量"><span class="toc-text">4. scala中声明变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-scala中数据类型"><span class="toc-text">5. scala中数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-scala中的条件表达式"><span class="toc-text">6.  scala中的条件表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-scala中的块表达式"><span class="toc-text">7. scala中的块表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-循环"><span class="toc-text">8. 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-方法和函数"><span class="toc-text">10. 方法和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-数组"><span class="toc-text">11. 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-元组"><span class="toc-text">12. 元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-映射Map"><span class="toc-text">13. 映射Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Set集合"><span class="toc-text">14. Set集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-列表-List"><span class="toc-text">15. 列表 List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-函数式编程"><span class="toc-text">16. 函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-高阶函数"><span class="toc-text">17. 高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-scala面向对象编程之类"><span class="toc-text">18. scala面向对象编程之类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-scala面向对象编程之对象"><span class="toc-text">19.scala面向对象编程之对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-scala面向对象编程之继承"><span class="toc-text">20. scala面向对象编程之继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-scala面向对象编程之trait特质"><span class="toc-text">21. scala面向对象编程之trait特质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-模式匹配和样例类"><span class="toc-text">22. 模式匹配和样例类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-异常处理"><span class="toc-text">23. 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-提取器-Extractor"><span class="toc-text">24. 提取器(Extractor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-泛型"><span class="toc-text">25. 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-协变、逆变、非变"><span class="toc-text">27. 协变、逆变、非变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-隐式转换和隐式参数"><span class="toc-text">28. 隐式转换和隐式参数</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 君子谦谦，温和有礼，有才而不骄，得志而不傲，居于谷而不卑。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        scala学习入门
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-06-07 23:51:59</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#-scala" title="-scala">-scala</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h3 id="1-scala简介"><a href="#1-scala简介" class="headerlink" title="1. scala简介"></a>1. scala简介</h3><ul>
<li>scala是运行在 JVM 上的多范式编程语言，同时支持==面向对象==和==面向函数编程==</li>
<li>早期scala刚出现的时候，并没有怎么引起重视，随着==Spark==和==Kafka==这样基于scala的大数据框架的兴起，scala逐步进入大数据开发者的眼帘。scala的主要优势是它的表达性。</li>
<li><p>官网地址</p>
</li>
<li><p><a href="http://www.scala-lang.org" target="_blank" rel="noopener">http://www.scala-lang.org</a></p>
</li>
</ul>
<h3 id="2-为什么用scala"><a href="#2-为什么用scala" class="headerlink" title="2. 为什么用scala"></a>2. 为什么用scala</h3><ul>
<li>开发大数据应用程序（Spark程序、Flink程序）</li>
<li>表达能力强，一行代码抵得上Java多行，开发速度快</li>
<li>兼容Java，可以访问庞大的Java类库</li>
</ul>
<h3 id="3-开发环境安装"><a href="#3-开发环境安装" class="headerlink" title="3. 开发环境安装"></a>3. 开发环境安装</h3><ul>
<li><p>学习如何编写scala代码之前，需要先安装scala编译器以及开发工具</p>
<ul>
<li><p>Java程序编译执行流程</p>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1556551819121.png" alt="1556551819121"></p>
</li>
<li><p>Scala程序编译执行流程</p>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1556551904384.png" alt="1556551904384"></p>
</li>
</ul>
</li>
<li><p>scala程序运行需要依赖于Java类库，必须要有<strong>==Java运行环境==</strong>，scala才能正确执行</p>
<ul>
<li><strong>要编译运行scala程序需要</strong><ul>
<li>==jdk  ( jvm )==</li>
<li>==scala编译器（scala SDK）==</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-scala中声明变量"><a href="#4-scala中声明变量" class="headerlink" title="4. scala中声明变量"></a>4. scala中声明变量</h3><ul>
<li><strong>1、语法格式</strong></li>
</ul>
<pre><code class="scala">val/var 变量名称:变量类型 = 初始值
</code></pre>
<ul>
<li><p>其中</p>
<ul>
<li><code>val</code>定义的是<strong>不可重新赋值</strong>的变量(值不可修改)</li>
<li><code>var</code>定义的是<strong>可重新赋值</strong>的变量(值可以修改)</li>
</ul>
</li>
<li><p>ps</p>
<ul>
<li>scala中声明变量是变量名称在前，变量类型在后，跟java是正好相反</li>
<li>scala的语句最后不需要添加分号</li>
</ul>
</li>
<li><p><strong>2、演示</strong></p>
<pre><code class="scala">#使用val声明变量,相当于java中的final修饰,不能在指向其他的数据了
 val  a:Int = 10
#使用var声明变量,后期可以被修改重新赋值
 var  b:Int = 20     
 b=100
#scala中的变量的类型可以显式的声明,也可以不声明,如果不显式的声明这会根据变量的值来推断出来变量的类型(scala支持类型推断)
 val c = 20
</code></pre>
</li>
</ul>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568103524126.png" alt="1568103524126"></p>
<ul>
<li><p>3、<strong>惰性变量</strong></p>
<ul>
<li>Scala中使用==关键字lazy==来定义惰性变量，实现延迟加载(懒加载)。 </li>
<li>惰性变量只能是不可变变量，并且只有在调用惰性变量时，才会去实例化这个变量。</li>
<li>语法格式</li>
</ul>
<pre><code class="scala">lazy val 变量名 = 表达式
</code></pre>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568104205830.png" alt="1568104205830"></p>
</li>
</ul>
<p>​         </p>
<h3 id="5-scala中数据类型"><a href="#5-scala中数据类型" class="headerlink" title="5. scala中数据类型"></a>5. scala中数据类型</h3><ul>
<li>scala中的类型绝大多数和Java一样</li>
<li>数据类型</li>
</ul>
<table>
<thead>
<tr>
<th>基础类型</th>
<th>类型说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td>8位带符号整数</td>
</tr>
<tr>
<td>Short</td>
<td>16位带符号整数</td>
</tr>
<tr>
<td><strong>Int</strong></td>
<td>32位带符号整数</td>
</tr>
<tr>
<td>Long</td>
<td>64位带符号整数</td>
</tr>
<tr>
<td>Char</td>
<td>16位无符号Unicode字符</td>
</tr>
<tr>
<td>String</td>
<td>Char类型的序列（字符串）</td>
</tr>
<tr>
<td>Float</td>
<td>32位单精度浮点数</td>
</tr>
<tr>
<td>Double</td>
<td>64位双精度浮点数</td>
</tr>
<tr>
<td>Boolean</td>
<td>true或false</td>
</tr>
</tbody>
</table>
<ul>
<li>=<strong>=注意下 scala类型与Java的区别</strong>==</li>
</ul>
<pre><code class="html">1. scala中所有的类型都使用大写字母开头
2. 整形使用Int而不是Integer
3. scala中定义变量可以不写类型，让scala编译器自动推断
</code></pre>
<ul>
<li>scala类型层次结构</li>
</ul>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1556592270468.png" alt="1556592270468"></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Any</td>
<td><strong>所有类型</strong>的父类，,它有两个子类AnyRef与AnyVal</td>
</tr>
<tr>
<td>AnyVal</td>
<td><strong>所有数值类型</strong>的父类</td>
</tr>
<tr>
<td>AnyRef</td>
<td>所有对象类型（引用类型）的父类</td>
</tr>
<tr>
<td>Unit</td>
<td>表示空，Unit是AnyVal的子类，它只有一个的实例（），它类似于Java中的void，但scala要比Java更加面向对象</td>
</tr>
<tr>
<td>Null</td>
<td>Null是AnyRef的子类，也就是说它是所有引用类型的子类。它的实例是null,   可以将null赋值给任何对象类型</td>
</tr>
<tr>
<td>Nothing</td>
<td>所有类型的<strong>子类</strong>不能直接创建该类型实例，某个方法抛出异常时，返回的就是Nothing类型，因为Nothing是所有类的子类，那么它可以赋值为任何类型</td>
</tr>
</tbody>
</table>
<pre><code>
</code></pre><h3 id="6-scala中的条件表达式"><a href="#6-scala中的条件表达式" class="headerlink" title="6.  scala中的条件表达式"></a>6.  scala中的条件表达式</h3><ul>
<li>条件表达式就是if表达式，if表达式可以根据给定的条件是否满足，根据条件的结果（真或假）决定执行对应的操作。scala条件表达式的语法和Java一样。</li>
</ul>
<pre><code class="scala">//定义变量x
scala&gt; val x =1
x: Int = 1

//if表达式
scala&gt; val y =if(x&gt;0) 1 else -1
y: Int = 1

//支持混合类型表达式
scala&gt; val z=if(x&gt;1) 1 else &quot;error&quot;
z: Any = error

//缺失else 相当于 if(x&gt;2) 1 else ()
scala&gt; val m=if(x&gt;2) 1
m: AnyVal = ()

//scala中有个Unit类，用作不返回任何结果的方法的结果类型,相当于Java中的void，Unit只有一个实例值，写成()
scala&gt; val n=if(x&gt;2) 1 else ()
n: AnyVal = ()

//if(xx) else if(xx) else 
scala&gt; val k=if(x&lt;0) -1 else if (x==0) 0 else 1
k: Int = 1
</code></pre>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568107951316.png" alt="1568107951316"></p>
<h3 id="7-scala中的块表达式"><a href="#7-scala中的块表达式" class="headerlink" title="7. scala中的块表达式"></a>7. scala中的块表达式</h3><ul>
<li>定义变量时用 {} 包含一系列表达式，其中块的最后一个表达式的值就是块的值。</li>
</ul>
<pre><code class="scala">val x=0 
val result={
  val y=x+10
  val z=y+&quot;-hello&quot;  
  val m=z+&quot;-kaikeba&quot;
    &quot;over&quot;
}
//result的值就是块表达式的结果    
//后期一个方法的返回值不需要加上return,把要返回的结果放在方法的最后一行就可以了 
</code></pre>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568108241418.png" alt="1568108241418"></p>
<ul>
<li>在scala解释器中先输入 ==:paste== ,然后写多行代码, 之后按===ctrl+d==结束输入</li>
</ul>
<h3 id="8-循环"><a href="#8-循环" class="headerlink" title="8. 循环"></a>8. 循环</h3><pre><code class="html">在scala中，可以使用for和while，但一般推荐使用for表达式，因为for表达式语法更简洁
</code></pre>
<ul>
<li>8.1 for循环</li>
</ul>
<ul>
<li><p>1、语法结构</p>
<pre><code class="scala">for (i &lt;- 表达式/数组/集合){
    //表达式
}
</code></pre>
</li>
<li><p>2、演示</p>
<ul>
<li>简单的for循环</li>
</ul>
<pre><code class="scala">//简单的for循环
scala&gt; val nums= 1 to 10
nums: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala&gt; for(i &lt;- nums) println(i)
1
2
3
4
5
6
7
8
9
10

</code></pre>
<ul>
<li>双重for循环</li>
</ul>
<pre><code class="scala">//双重for循环
scala&gt;  for(i &lt;- 1 to 3; j &lt;- 1 to 3) println(i*10+j)
11
12
13
21
22
23
31
32
33

//双重for循环打印99乘法表
for(i &lt;- 1 to 9; j &lt;- 1 to i){
    print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;)
     if(i==j){
       println()
    }    
} 

1*1=1
2*1=2   2*2=4
3*1=3   3*2=6   3*3=9
4*1=4   4*2=8   4*3=12  4*4=16
5*1=5   5*2=10  5*3=15  5*4=20  5*5=25
6*1=6   6*2=12  6*3=18  6*4=24  6*5=30  6*6=36
7*1=7   7*2=14  7*3=21  7*4=28  7*5=35  7*6=42  7*7=49
8*1=8   8*2=16  8*3=24  8*4=32  8*5=40  8*6=48  8*7=56  8*8=64
9*1=9   9*2=18  9*3=27  9*4=36  9*5=45  9*6=54  9*7=63  9*8=72  9*9=81
</code></pre>
<ul>
<li>守卫<ul>
<li>在for表达式中可以添加if判断语句，这个if判断就称为守卫</li>
</ul>
</li>
</ul>
<pre><code class="scala">//语法结构
for(i &lt;- 表达式/数组/集合 if 表达式) {
    // 表达式
}

scala&gt; for(i &lt;- 1 to 10 if i &gt;5) println(i)
6
7
8
9
10

</code></pre>
<ul>
<li>for推导式<ul>
<li>在for循环体中，可以使用yield表达式构建出一个集合，我们把使用yield的for表达式称之为推导式</li>
</ul>
</li>
</ul>
<pre><code class="scala">// for推导式：for表达式中以yield开始，该for表达式会构建出一个集合

val v = for(i &lt;- 1 to 5) yield i * 10
</code></pre>
</li>
</ul>
<ul>
<li>8.2 while循环</li>
</ul>
<ul>
<li>scala中while循环和Java中是一致的</li>
<li>语法结构</li>
</ul>
<pre><code class="scala">while(返回值为布尔类型的表达式){
    //表达式
}
</code></pre>
<ul>
<li>演示</li>
</ul>
<pre><code class="scala">scala&gt; var x = 10
x: Int = 10

scala&gt; while(x &gt;5){
     | println(x)
     | x -= 1
     | }
10
9
8
7
6
</code></pre>
<h3 id="10-方法和函数"><a href="#10-方法和函数" class="headerlink" title="10. 方法和函数"></a>10. 方法和函数</h3><ul>
<li>10.1 方法</li>
</ul>
<ul>
<li>语法</li>
</ul>
<pre><code class="scala">def methodName (参数名:参数类型, 参数名:参数类型) : [return type] = {
    // 方法体：一系列的代码
}
</code></pre>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568110629253.png" alt="1568110629253"></p>
<ul>
<li><p>说明</p>
<pre><code class="html">- 参数列表的参数类型不能省略
- 返回值类型可以省略，由scala编译器自动推断
- 返回值可以不写return，默认就是{}块表达式的值

</code></pre>
</li>
<li><p>演示</p>
<pre><code class="scala">scala&gt; def add(a:Int,b:Int) = a+b
add: (a: Int, b: Int)Int

scala&gt; add(1,2)
res8: Int = 3

scala&gt;

</code></pre>
</li>
<li><p>注意</p>
<ul>
<li>如果定义递归方法，不能省略返回值类型</li>
<li>示例：<ul>
<li>定义递归方法（求阶乘）<ul>
<li>10 <em> 9 </em> 8 <em> 7 </em> 6 <em> … </em> 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="scala">scala&gt; def m1(x:Int)={
     | if(x==1) 1
     | else x * m1(x-1)
     | }
&lt;console&gt;:14: error: recursive method m1 needs result type
       else x * m1(x-1)
                ^

scala&gt; def m1(x:Int):Int={
     | if(x==1) 1
     | else x * m1(x-1)
     | }
m1: (x: Int)Int

scala&gt; m1(10)
res9: Int = 3628800

</code></pre>
</li>
</ul>
<ul>
<li><p>方法的参数</p>
<ul>
<li><p>1、默认参数</p>
<ul>
<li><p>在定义方法时可以给参数定义一个默认值。</p>
</li>
<li><p>示例</p>
<pre><code class="scala">//1. 定义一个计算两个值相加的方法，这两个值默认为0
//2. 调用该方法

scala&gt; def add(x:Int = 0, y:Int = 0) = x + y
add: (x: Int, y: Int)Int

scala&gt; add(10)
res14: Int = 10

scala&gt; add(10,20)
res15: Int = 30

</code></pre>
</li>
</ul>
</li>
<li><p>2、带名参数</p>
<ul>
<li><p>在调用方法时，可以指定参数的名称来进行调用。</p>
</li>
<li><p>示例</p>
</li>
</ul>
<pre><code class="scala">scala&gt; def add(x:Int = 0, y:Int = 0) = x + y
add: (x: Int, y: Int)Int

scala&gt; add(x=1)
res16: Int = 1

</code></pre>
</li>
<li><p>3、变长参数</p>
<ul>
<li><p>如果方法的参数是不固定的，可以定义一个方法的参数是变长参数。</p>
</li>
<li><p>语法格式：</p>
<pre><code class="scala">def 方法名(参数名:参数类型*):返回值类型 = {
    方法体
}

//在参数类型后面加一个*号，表示参数可以是0个或者多个
</code></pre>
</li>
<li><p>示例</p>
<pre><code class="scala">scala&gt; def add(num:Int*) = num.sum
add: (num: Int*)Int

scala&gt; add(1,2,3,4,5)
res17: Int = 15
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>10.2 函数</li>
</ul>
<ul>
<li>scala支持函数式编程，将来编写Spark/Flink程序中，会大量使用到函数</li>
<li>语法</li>
</ul>
<pre><code class="scala">val 函数变量名 = (参数名:参数类型, 参数名:参数类型....) =&gt; 函数体
</code></pre>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568111630788.png" alt="1568111630788"></p>
<ul>
<li>注意</li>
</ul>
<pre><code class="html">- 函数是一个对象（变量）
- 类似于方法，函数也有输入参数和返回值
- 函数定义不需要使用def定义
- 无需指定返回值类型
</code></pre>
<ul>
<li>演示</li>
</ul>
<pre><code class="scala">scala&gt; val add = (x:Int, y:Int) =&gt; x + y
add: (Int, Int) =&gt; Int = &lt;function2&gt;

scala&gt; add(1,2)
res3: Int = 3


//一个函数没有赋予一个变量，则称为匿名函数，
//后期再实际开发代码的时候，基本上都是使用匿名函数
(x:Int,y:Int)=&gt;x+y
</code></pre>
<ul>
<li>10.3 方法和函数的区别</li>
</ul>
<ul>
<li>方法是隶属于类或者对象的，在运行时，它是加载到JVM的方法区中</li>
<li>可以将函数对象赋值给一个变量，在运行时，它是加载到JVM的堆内存中</li>
<li>==函数是一个对象，继承自FunctionN==，函数对象有apply，curried，toString，tupled这些方法，而方法则没有</li>
</ul>
<ul>
<li>10.4 方法转换为函数</li>
</ul>
<ul>
<li><p>有时候需要将方法转换为函数，作为变量传递，就需要将方法转换为函数</p>
</li>
<li><p>使用<code>_</code>即可将方法转换为函数</p>
</li>
<li><p>示例</p>
<pre><code class="scala">scala&gt; def add(x:Int,y:Int)=x+y
add: (x: Int, y: Int)Int

scala&gt; val a = add _
a: (Int, Int) =&gt; Int = &lt;function2&gt;
</code></pre>
</li>
</ul>
<h3 id="11-数组"><a href="#11-数组" class="headerlink" title="11. 数组"></a>11. 数组</h3><ul>
<li>scala中数组的概念是和Java类似，可以用数组来存放一组数据</li>
<li>scala中，有两种数组，一种是<strong>定长数组</strong>，另一种是<strong>变长数组</strong></li>
</ul>
<ul>
<li>11.1 定长数组</li>
</ul>
<ul>
<li><p>定长数组指的是数组的<strong>长度</strong>是<strong>不允许改变</strong>的</p>
</li>
<li><p>数组的<strong>元素</strong>是<strong>可以改变</strong>的</p>
</li>
<li><p>语法</p>
<pre><code class="scala">// 通过指定长度定义数组
val/var 变量名 = new Array[元素类型](数组长度)

// 用元素直接初始化数组
val/var 变量名 = Array(元素1, 元素2, 元素3...)

</code></pre>
</li>
<li><p>注意</p>
<pre><code class="html">在scala中，数组的泛型使用[]来指定
使用()来获取元素

</code></pre>
</li>
<li><p>演示</p>
<pre><code class="scala">scala&gt; val a=new Array[Int](10)
a: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

scala&gt; a(0)
res19: Int = 0

scala&gt; a(0)=10

scala&gt; a
res21: Array[Int] = Array(10, 0, 0, 0, 0, 0, 0, 0, 0, 0)

//////////////////////////////////////////////////////////////////
scala&gt; val b =Array(&quot;hadoop&quot;,&quot;spark&quot;,&quot;hive&quot;)
b: Array[String] = Array(hadoop, spark, hive)

scala&gt; b(0)
res24: String = hadoop

scala&gt; b.length
res25: Int = 3
</code></pre>
</li>
</ul>
<ul>
<li>11.2 变长数组</li>
</ul>
<ul>
<li><p>变长数组指的是数组的长度是可变的，可以往数组中添加、删除元素</p>
</li>
<li><p>创建变长数组，需要提前导入ArrayBuffer类</p>
<pre><code class="scala">import scala.collection.mutable.ArrayBuffer
</code></pre>
</li>
<li><p>语法</p>
<ul>
<li>创建空的ArrayBuffer变长数组</li>
</ul>
<pre><code class="scala">val/var a = ArrayBuffer[元素类型]()
</code></pre>
<ul>
<li>创建带有初始元素的ArrayBuffer</li>
</ul>
<pre><code class="scala">val/var a = ArrayBuffer(元素1，元素2，元素3....)
</code></pre>
</li>
<li><p>演示</p>
<pre><code class="scala">//导入ArrayBuffer类型
scala&gt; import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.ArrayBuffer

//定义一个长度为0的整型变长数组
scala&gt; val a=ArrayBuffer[Int]()
a: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()

//定义一个有初始元素的变长数组
scala&gt; val b = ArrayBuffer(&quot;hadoop&quot;, &quot;storm&quot;, &quot;spark&quot;)
b: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(hadoop, storm, spark)
</code></pre>
</li>
<li><p>变长数组的增删改操作</p>
<ul>
<li>使用<code>+=</code>添加元素</li>
<li>使用<code>-=</code>删除元素</li>
<li>使用<code>++=</code>追加一个数组到变长数组</li>
</ul>
</li>
<li><p>示例</p>
<pre><code class="scala">// 定义变长数组
scala&gt; val a = ArrayBuffer(&quot;hadoop&quot;, &quot;spark&quot;, &quot;flink&quot;)
a: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(hadoop, spark, flink)

// 追加一个元素
scala&gt; a += &quot;flume&quot;
res10: a.type = ArrayBuffer(hadoop, spark, flink, flume)

// 删除一个元素
scala&gt; a -= &quot;hadoop&quot;
res11: a.type = ArrayBuffer(spark, flink, flume)

// 追加一个数组
scala&gt; a ++= Array(&quot;hive&quot;, &quot;sqoop&quot;)
res12: a.type = ArrayBuffer(spark, flink, flume, hive, sqoop)

</code></pre>
</li>
</ul>
<ul>
<li>11.3 遍历数组</li>
</ul>
<ul>
<li><p>可以使用以下两种方式来遍历数组：</p>
<ul>
<li>使用==for表达式== 直接遍历数组中的元素</li>
<li>使用 ==索引== 遍历数组中的元素</li>
</ul>
</li>
<li><p>示例</p>
</li>
</ul>
<pre><code class="scala">scala&gt; for(i &lt;- a)println(i)
hadoop
hive
flume
spark

scala&gt; for(i &lt;- 0 to a.length -1 )println(a(i))
hadoop
hive
flume
spark

scala&gt; for(i &lt;- 0 until a.length) println(a(i))
hadoop
hive
flume
spark


//0 until n ——生成一系列的数字，包含0，不包含n
//0 to n    ——包含0，也包含n

</code></pre>
<ul>
<li>11.4 数组常用操作</li>
</ul>
<ul>
<li>scala中的数组封装了丰富的计算操作，将来在对数据处理的时候，不需要我们自己再重新实现。<ul>
<li>求和——sum方法</li>
<li>求最大值——max方法 </li>
<li>求最小值——min方法 </li>
<li>排序——sorted方法</li>
</ul>
</li>
<li>示例</li>
</ul>
<pre><code class="scala">scala&gt; val array=Array(1,3,4,2,5)
array: Array[Int] = Array(1, 3, 4, 2, 5)

//求和
scala&gt; array.sum
res10: Int = 15

//求最大值
scala&gt; array.max
res11: Int = 5

//求最小值
scala&gt; array.min
res12: Int = 1

//升序
scala&gt; array.sorted
res13: Array[Int] = Array(1, 2, 3, 4, 5)

//降序    reverse 反转
scala&gt; array.sorted.reverse
res14: Array[Int] = Array(5, 4, 3, 2, 1)

</code></pre>
<h3 id="12-元组"><a href="#12-元组" class="headerlink" title="12. 元组"></a>12. 元组</h3><ul>
<li>元组可以用来包含一组不同类型的值。例如：姓名，年龄，性别，出生年月。元组的元素是不可变 的。</li>
</ul>
<ul>
<li>12.1 定义元组</li>
</ul>
<ul>
<li><p>语法</p>
<ul>
<li><p>使用括号来定义元组</p>
<pre><code class="scala">val/var 元组变量名称 = (元素1, 元素2, 元素3....)
</code></pre>
</li>
<li><p>使用箭头来定义元素（元组只有两个元素）</p>
<pre><code class="scala">val/var 元组 = 元素1-&gt;元素2
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li>12.2 示例</li>
</ul>
<pre><code class="scala">// 可以直接使用括号来定义一个元组 
scala&gt; val a = (1, &quot;张三&quot;, 20, &quot;北京市&quot;) 
a: (Int, String, Int, String) = (1,张三,20,北京市)

//使用箭头来定义元素
scala&gt; val b = 1-&gt;2 
b: (Int, Int) = (1,2)

</code></pre>
<ul>
<li>12.3 访问元组</li>
</ul>
<ul>
<li><p>使用</p>
<pre><code class="html"> _1、_2、_3....

</code></pre>
<p>来访问元组中的元素，_1表示访问第一个元素，依次类推</p>
</li>
<li><p>示例</p>
</li>
</ul>
<pre><code class="scala">scala&gt; val a = (1, &quot;张三&quot;, 20, &quot;北京市&quot;)
a: (Int, String, Int, String) = (1,张三,20,北京市)

//获取元组中的第一个元素
scala&gt; a._1
res18: Int = 1

//获取元组中的第二个元素
scala&gt; a._2
res19: String = 张三

//获取元组中的第三个元素
scala&gt; a._3
res20: Int = 20

//获取元组中的第四个元素
scala&gt; a._4
res21: String = 北京市

//不能修改元组中的值
scala&gt; a._4=&quot;上海&quot;
&lt;console&gt;:12: error: reassignment to val
       a._4=&quot;上海&quot;
           ^


</code></pre>
<h3 id="13-映射Map"><a href="#13-映射Map" class="headerlink" title="13. 映射Map"></a>13. 映射Map</h3><ul>
<li>Map可以称之为映射。它是由键值对组成的集合。scala当中的Map集合与java当中的Map类似，也是key，value对形式的。</li>
<li>在scala中，Map也分为不可变Map和可变 Map。</li>
</ul>
<ul>
<li>13.1 不可变Map</li>
</ul>
<ul>
<li>定义语法</li>
</ul>
<pre><code class="scala">val/var map = Map(键-&gt;值, 键-&gt;值, 键-&gt;值...)    // 推荐，可读性更好 
val/var map = Map((键, 值), (键, 值), (键, 值), (键, 值)...)
</code></pre>
<ul>
<li>演示</li>
</ul>
<pre><code class="scala">scala&gt; val map1 = Map(&quot;zhangsan&quot;-&gt;30, &quot;lisi&quot;-&gt;40) 
map: scala.collection.immutable.Map[String,Int] = Map(zhangsan -&gt; 30, lisi -&gt; 40)

scala&gt; val map2 = Map((&quot;zhangsan&quot;, 30), (&quot;lisi&quot;, 30)) 
map: scala.collection.immutable.Map[String,Int] = Map(zhangsan -&gt; 30, lisi -&gt; 30)
// 根据key获取value 
scala&gt; map1(&quot;zhangsan&quot;) 
res10: Int = 30
</code></pre>
<ul>
<li>13.2 可变Map</li>
</ul>
<ul>
<li><p>可变Map需要手动导入==import scala.collection.mutable.Map==, 定义语法与不可变Map一致。</p>
</li>
<li><p>演示</p>
</li>
</ul>
<pre><code class="scala">//导包
scala&gt; import scala.collection.mutable.Map
import scala.collection.mutable.Map

//定义可变的map
scala&gt; val map3 = Map(&quot;zhangsan&quot;-&gt;30, &quot;lisi&quot;-&gt;40)
map3: scala.collection.mutable.Map[String,Int] = Map(lisi -&gt; 40, zhangsan -&gt; 30)

//获取zhangsan这个key对应的value
scala&gt; map3(&quot;zhangsan&quot;)
res26: Int = 30

//给zhangsan这个key重新赋值value
scala&gt; map3(&quot;zhangsan&quot;)=50

//显示map3
scala&gt; map3
res28: scala.collection.mutable.Map[String,Int] = Map(lisi -&gt; 40, zhangsan -&gt; 50)


</code></pre>
<ul>
<li>13.3 Map基本操作</li>
</ul>
<ul>
<li>创建一个可变的map</li>
</ul>
<pre><code class="scala">//导包
scala&gt; import scala.collection.mutable.Map
import scala.collection.mutable.Map

scala&gt; val map = Map(&quot;zhangsan&quot;-&gt;30, &quot;lisi&quot;-&gt;40) 
map: scala.collection.mutable.Map[String,Int] = Map(lisi -&gt; 40, zhangsan -&gt; 30)

</code></pre>
<ul>
<li>按照key获取value</li>
</ul>
<pre><code class="scala">// 获取zhagnsan的年龄 
scala&gt; map(&quot;zhangsan&quot;)
res10: Int = 30

// 获取wangwu的年龄，如果wangwu不存在，则返回-1 比较友好，避免遇到不存在的key而报错
scala&gt; map.getOrElse(&quot;wangwu&quot;, -1) 
res11: Int = -1


</code></pre>
<ul>
<li>修改key对应的value</li>
</ul>
<pre><code class="scala">scala&gt; map(&quot;lisi&quot;)=50

</code></pre>
<ul>
<li>添加key-value键值对</li>
</ul>
<pre><code class="scala">scala&gt; map+=(&quot;wangwu&quot; -&gt;35)
res12: map.type = Map(lisi -&gt; 50, zhangsan -&gt; 30, wangwu -&gt; 35)



</code></pre>
<ul>
<li>删除key-value键值对</li>
</ul>
<pre><code class="scala">scala&gt; map -=&quot;wangwu&quot;
res13: map.type = Map(lisi -&gt; 50, zhangsan -&gt; 30)
</code></pre>
<ul>
<li>获取所有的key和所有的value</li>
</ul>
<pre><code class="scala">//获取所有的key
scala&gt; map.keys
res36: Iterable[String] = Set(lisi, zhangsan)

//获取所有的key
scala&gt; map.keySet
res37: scala.collection.Set[String] = Set(lisi, zhangsan)

//获取所有的value
scala&gt; map.values
res38: Iterable[Int] = HashMap(50, 30)
</code></pre>
<ul>
<li>遍历map</li>
</ul>
<pre><code class="scala">//第一种遍历
scala&gt; for(k &lt;- map.keys) println(k+&quot; -&gt; &quot; +map(k))
lisi -&gt; 50
zhangsan -&gt; 30


//第二种遍历
scala&gt; for((k,v) &lt;- map) println(k+&quot; -&gt; &quot;+v)
lisi -&gt; 50
zhangsan -&gt; 30
</code></pre>
<h3 id="14-Set集合"><a href="#14-Set集合" class="headerlink" title="14. Set集合"></a>14. Set集合</h3><ul>
<li>Set是代表没有重复元素的集合。</li>
<li>Set具备以下性质：<ul>
<li>1、元素不重复 </li>
<li>2、不保证插入顺序</li>
</ul>
</li>
<li>scala中的set集合也分为两种，一种是不可变集合，另一种是可变集合。</li>
</ul>
<ul>
<li>14.1 不可变Set集合</li>
</ul>
<ul>
<li>语法</li>
</ul>
<pre><code class="scala">//创建一个空的不可变集
val/var 变量名 = Set[类型]()

//给定元素来创建一个不可变集
val/var 变量名 = Set[类型](元素1, 元素2, 元素3...)

</code></pre>
<ul>
<li>演示</li>
</ul>
<pre><code class="scala">// 创建set集合 
scala&gt; val a = Set(1,1,2,3,4,5) 
a: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)

// 获取集合的大小 
scala&gt; a.size 
res0: Int = 5

// 遍历集合
scala&gt; for(i &lt;- a) println(i)

//添加元素生成新的集合
scala&gt; a + 6
res1: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 2, 3, 4)

// 删除一个元素 
scala&gt; a - 1 
res2: scala.collection.immutable.Set[Int] = Set(5, 2, 3, 4)

// 删除set集合中存在的元素 
scala&gt; a -- Set(2,3) 
res3: scala.collection.immutable.Set[Int] = Set(5, 1, 4)

// 拼接两个集合 
scala&gt; a ++ Set(6,7,8) 
res4: scala.collection.immutable.Set[Int] = Set(5, 1, 6, 2, 7, 3, 8, 4)

//求2个Set集合的交集
scala&gt; a &amp; Set(3,4,5,6)
res5: scala.collection.immutable.Set[Int] = Set(5, 3, 4)



//注意：这里对不可变的set集合进行添加删除等操作，对于该集合来说是没有发生任何变化，这里是生成了新的集合，新的集合相比于原来的集合来说发生了变化。
</code></pre>
<ul>
<li>14.2 可变Set集合</li>
</ul>
<ul>
<li>要使用可变集，必须要手动导入： ==import scala.collection.mutable.Set==</li>
<li>演示</li>
</ul>
<pre><code class="scala">//导包
scala&gt; import scala.collection.mutable.Set
import scala.collection.mutable.Set

//定义可变的set集合
scala&gt; val set=Set(1,2,3,4,5)
set: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

//添加单个元素
scala&gt; set +=6
res10: set.type = Set(1, 5, 2, 6, 3, 4)

//添加多个元素
scala&gt; set +=(6,7,8,9)
res11: set.type = Set(9, 1, 5, 2, 6, 3, 7, 4, 8)

//添加一个set集合中的元素
scala&gt; set ++=Set(10,11)
res12: set.type = Set(9, 1, 5, 2, 6, 3, 10, 7, 4, 11, 8)

//删除一个元素
scala&gt; set -=11
res13: set.type = Set(9, 1, 5, 2, 6, 3, 10, 7, 4, 8)

//删除多个元素
scala&gt; set -=(9,10)
res15: set.type = Set(1, 5, 2, 6, 3, 7, 4, 8)

//删除一个set子集
scala&gt; set --=Set(7,8)
res19: set.type = Set(1,5, 2, 6, 3, 4)

scala&gt; set.remove(1)
res17: Boolean = true

scala&gt; set
res18: scala.collection.mutable.Set[Int] = Set(5, 2, 6, 3, 4)

</code></pre>
<h3 id="15-列表-List"><a href="#15-列表-List" class="headerlink" title="15. 列表 List"></a>15. 列表 List</h3><ul>
<li>List是scala中最重要的、也是最常用的数据结构。</li>
<li><p>List具备以下性质：</p>
<ul>
<li>1、可以保存重复的值 </li>
<li>2、有先后顺序</li>
</ul>
</li>
<li><p>在scala中，也有两种列表，一种是不可变列表、另一种是可变列表</p>
</li>
</ul>
<ul>
<li>15.1 不可变列表</li>
</ul>
<ul>
<li>不可变列表就是列表的元素、长度都是不可变的</li>
<li>语法<ul>
<li>使用 List(元素1, 元素2, 元素3, …) 来创建一个不可变列表，语法格式</li>
</ul>
</li>
</ul>
<pre><code class="scala">val/var 变量名 = List(元素1, 元素2, 元素3...)

//使用 Nil 创建一个不可变的空列表
val/var 变量名 = Nil

//使用 :: 方法创建一个不可变列表
val/var 变量名 = 元素1 :: 元素2 :: Nil

</code></pre>
<ul>
<li>演示</li>
</ul>
<pre><code class="scala">//创建一个不可变列表，存放以下几个元素（1,2,3,4）
scala&gt; val  list1=List(1,2,3,4)
list1: List[Int] = List(1, 2, 3, 4)

//使用Nil创建一个不可变的空列表
scala&gt; val  list2=Nil
list2: scala.collection.immutable.Nil.type = List()

//使用 :: 方法创建列表，包含1、2、3三个元素
scala&gt; val list3=1::2::3::Nil
list3: List[Int] = List(1, 2, 3)
</code></pre>
<ul>
<li>15.2 可变列表</li>
</ul>
<ul>
<li><p>可变列表就是列表的元素、长度都是可变的。</p>
</li>
<li><p>要使用可变列表，先要导入 ==import scala.collection.mutable.ListBuffer==</p>
</li>
<li><p>语法</p>
<ul>
<li>使用ListBuffer<a href="">元素类型</a> 创建空的可变列表，语法结构</li>
</ul>
<pre><code class="scala">val/var 变量名 = ListBuffer[Int]()
</code></pre>
<ul>
<li>使用ListBuffer(元素1, 元素2, 元素3…)创建可变列表，语法结构</li>
</ul>
<pre><code class="scala">val/var 变量名 = ListBuffer(元素1，元素2，元素3...)
</code></pre>
</li>
<li><p>演示</p>
<pre><code class="scala">//导包
scala&gt; import scala.collection.mutable.ListBuffer
import scala.collection.mutable.ListBuffer

//定义一个空的可变列表
scala&gt; val a=ListBuffer[Int]()
a: scala.collection.mutable.ListBuffer[Int] = ListBuffer()

//定义一个有初始元素的可变列表
scala&gt; val b=ListBuffer(1,2,3,4)
b: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4)
</code></pre>
</li>
</ul>
<ul>
<li>15.3 列表操作</li>
</ul>
<pre><code class="scala">//导包
scala&gt; import scala.collection.mutable.ListBuffer
import scala.collection.mutable.ListBuffer

//定义一个可变的列表
scala&gt; val list=ListBuffer(1,2,3,4)
list: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4)

//获取第一个元素
scala&gt; list(0)
res4: Int = 1
//获取第一个元素
scala&gt; list.head
res5: Int = 1

//获取除了第一个元素外其他元素组成的列表
scala&gt; list.tail
res6: scala.collection.mutable.ListBuffer[Int] = ListBuffer(2, 3, 4)

//添加单个元素
scala&gt; list +=5
res7: list.type = ListBuffer(1, 2, 3, 4, 5)

//添加一个不可变的列表
scala&gt; list ++=List(6,7)
res8: list.type = ListBuffer(1, 2, 3, 4, 5, 6, 7)

//添加一个可变的列表
scala&gt; list ++=ListBuffer(8,9)
res9: list.type = ListBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9)

//删除单个元素
scala&gt; list -=9
res10: list.type = ListBuffer(1, 2, 3, 4, 5, 6, 7, 8)

//删除一个不可变的列表存在的元素
scala&gt; list --=List(7,8)
res11: list.type = ListBuffer(1, 2, 3, 4, 5, 6)

//删除一个可变的列表存在的元素
scala&gt; list --=ListBuffer(5,6)
res12: list.type = ListBuffer(1, 2, 3, 4)

//可变的列表转为不可变列表
scala&gt; list.toList
res13: List[Int] = List(1, 2, 3, 4)

//可变的列表转为不可变数组
scala&gt; list.toArray
res14: Array[Int] = Array(1, 2, 3, 4)
</code></pre>
<h3 id="16-函数式编程"><a href="#16-函数式编程" class="headerlink" title="16. 函数式编程"></a>16. 函数式编程</h3><ul>
<li>我们将来使用Spark/Flink的大量业务代码都会使用到函数式编程。</li>
<li>下面的这些操作是学习的重点，先来感受下如何进行函数式编程以及它的强大</li>
</ul>
<ul>
<li>16.1 遍历 - foreach</li>
</ul>
<ul>
<li><p>方法描述</p>
<pre><code class="scala">foreach(f: (A) ⇒ Unit): Unit
</code></pre>
</li>
<li><p>方法说明</p>
<p>| foreach | API           | 说明                                                         |<br>| ——- | ————- | ———————————————————— |<br>| 参数    | f: (A) ⇒ Unit | 接收一个函数对象<br>函数的输入参数为集合的元素<br>返回值为空 |<br>| 返回值  | Unit          | 空                                                           |</p>
</li>
<li><p>方法实操</p>
</li>
</ul>
<pre><code class="scala">scala&gt; val list=List(1,2,3,4)
list: List[Int] = List(1, 2, 3, 4)

//定义一个匿名函数传入到foreach方法中
scala&gt; list.foreach((x:Int)=&gt;println(x))
1
2
3
4

//匿名函数的输入参数类型可以省略，由编译器自动推断
scala&gt; list.foreach(x=&gt;println(x))
1
2
3
4

//当函数参数，只在函数体中出现一次，而且函数体没有嵌套调用时，可以使用下划线来简化函数定 义
scala&gt; list.foreach(println(_))
1
2
3
4

//最简写，直接给定println
scala&gt; list.foreach(println)
1
2
3
4

//很神奇的语法，别害怕，盘它就可以了，后期通过scala语言开发spark、Flink程序非常简洁方便
</code></pre>
<ul>
<li>16.2 映射 - map</li>
</ul>
<ul>
<li><p>集合的映射操作是将来在编写Spark/Flink用得最多的操作，是我们必须要掌握的掌握。</p>
</li>
<li><p>方法描述</p>
</li>
</ul>
<pre><code class="scala">def map[B](f: (A) ⇒ B): TraversableOnce[B]
</code></pre>
<ul>
<li>方法说明</li>
</ul>
<table>
<thead>
<tr>
<th>map方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>泛型</td>
<td>[B]</td>
<td>指定map方法最终返回的集合泛型</td>
</tr>
<tr>
<td>参数</td>
<td>f: (A) ⇒ B</td>
<td>传入一个函数对象<br>该函数接收一个类型A（要转换的列表元素）<br>返回值为类型B</td>
</tr>
<tr>
<td>返回值</td>
<td>TraversableOnce[B]</td>
<td>B类型的集合</td>
</tr>
</tbody>
</table>
<ul>
<li>方法实操</li>
</ul>
<pre><code class="scala">//定义一个list集合，实现把内部每一个元素做乘以10，生成一个新的list集合
scala&gt; val list=List(1,2,3,4)
list: List[Int] = List(1, 2, 3, 4)

//定义一个匿名函数
scala&gt; list.map((x:Int)=&gt;x*10)
res21: List[Int] = List(10, 20, 30, 40)

//省略匿名函数参数类型
scala&gt; list.map(x=&gt;x*10)
res22: List[Int] = List(10, 20, 30, 40)

//最简写   用下划线
scala&gt; list.map(_*10)
res23: List[Int] = List(10, 20, 30, 40)
</code></pre>
<ul>
<li>16.3 扁平化映射 - flatmap</li>
</ul>
<ul>
<li>映射扁平化也是将来用得非常多的操作，也是必须要掌握的。</li>
<li>方法描述</li>
</ul>
<pre><code class="scala">def flatMap[B](f: (A) ⇒ GenTraversableOnce[B]): TraversableOnce[B]
</code></pre>
<ul>
<li>方法说明</li>
</ul>
<table>
<thead>
<tr>
<th>flatmap方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>泛型</td>
<td>[B]</td>
<td>最终要转换的集合元素类型</td>
</tr>
<tr>
<td>参数</td>
<td>f: (A) ⇒ GenTraversableOnce[B]</td>
<td>传入一个函数对象<br>函数的参数是集合的元素<br>函数的返回值是一个集合</td>
</tr>
<tr>
<td>返回值</td>
<td>TraversableOnce[B]</td>
<td>B类型的集合</td>
</tr>
</tbody>
</table>
<ul>
<li>方法实操</li>
</ul>
<pre><code class="scala">//定义一个List集合,每一个元素中就是一行数据，有很多个单词
scala&gt;  val list = List(&quot;hadoop hive spark flink&quot;, &quot;hbase spark&quot;)
list: List[String] = List(hadoop hive spark flink, hbase spark)

//使用flatMap进行偏平化处理，获取得到所有的单词
scala&gt; list.flatMap(x =&gt; x.split(&quot; &quot;))
res24: List[String] = List(hadoop, hive, spark, flink, hbase, spark)

//简写
scala&gt; list.flatMap(_.split(&quot; &quot;))
res25: List[String] = List(hadoop, hive, spark, flink, hbase, spark)

// flatMap该方法其本质是先进行了map 然后又调用了flatten
scala&gt; list.map(_.split(&quot; &quot;)).flatten
res26: List[String] = List(hadoop, hive, spark, flink, hbase, spark)
</code></pre>
<ul>
<li>16.4 过滤 - filter</li>
</ul>
<ul>
<li>过滤符合一定条件的元素</li>
</ul>
<ul>
<li>方法描述</li>
</ul>
<pre><code class="scala">def filter(p: (A) ⇒ Boolean): TraversableOnce[A]
</code></pre>
<ul>
<li>方法说明</li>
</ul>
<table>
<thead>
<tr>
<th>filter方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数</td>
<td>p: (A) ⇒ Boolean</td>
<td>传入一个函数对象<br>接收一个集合类型的参数<br>返回布尔类型，满足条件返回true, 不满足返回false</td>
</tr>
<tr>
<td>返回值</td>
<td>TraversableOnce[A]</td>
<td>列表</td>
</tr>
</tbody>
</table>
<ul>
<li>方法实操</li>
</ul>
<pre><code class="scala">//定义一个list集合
scala&gt; val list=List(1,2,3,4,5,6,7,8,9,10)
list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

//过滤出集合中大于5的元素
scala&gt; list.filter(x =&gt; x &gt;5)
res27: List[Int] = List(6, 7, 8, 9, 10)

//把集合中大于5的元素取出来乘以10生成一个新的list集合
scala&gt; list.filter(_ &gt; 5).map(_ * 10)
res29: List[Int] = List(60, 70, 80, 90, 100)


//通过这个案例，应该是可以感受到scala比java的强大了...
</code></pre>
<ul>
<li>16.5 排序 - sort</li>
</ul>
<ul>
<li>在scala集合中，可以使用以下几种方式来进行排序<ul>
<li>sorted默认排序 </li>
<li>sortBy指定字段排序 </li>
<li>sortWith自定义排序</li>
</ul>
</li>
<li>==sorted默认排序== </li>
</ul>
<pre><code class="scala">//定义一个List集合
scala&gt; val list=List(5,1,2,4,3)
list: List[Int] = List(5, 1, 2, 4, 3)

//默认就是升序
scala&gt; list.sorted
res30: List[Int] = List(1, 2, 3, 4, 5)
</code></pre>
<ul>
<li><p>==sortBy指定字段排序==</p>
<ul>
<li>根据传入的函数转换后，再进行排序</li>
<li>方法描述</li>
</ul>
<pre><code class="scala">def sortBy[B](f: (A) ⇒ B): List[A]
</code></pre>
<ul>
<li>方法说明</li>
</ul>
<p>| sortBy方法 | API        | 说明                                                         |<br>| ———- | ———- | ———————————————————— |<br>| 泛型       | [B]        | 按照什么类型来进行排序                                       |<br>| 参数       | f: (A) ⇒ B | 传入函数对象<br>接收一个集合类型的元素参数<br>返回B类型的元素进行排序 |<br>| 返回值     | List[A]    | 返回排序后的列表                                             |</p>
<ul>
<li>方法实操</li>
</ul>
<pre><code class="scala">//定义一个List集合
scala&gt; val list=List(&quot;1 hadoop&quot;,&quot;2 spark&quot;,&quot;3 flink&quot;)
list: List[String] = List(1 hadoop, 2 spark, 3 flink)

//按照单词的首字母进行排序
scala&gt; list.sortBy(x=&gt;x.split(&quot; &quot;)(1))
res33: List[String] = List(3 flink, 1 hadoop, 2 spark)

</code></pre>
</li>
<li><p>==sortWith自定义排序==</p>
<ul>
<li>自定义排序，根据一个函数来进行自定义排序</li>
<li>方法描述</li>
</ul>
<pre><code class="scala">def sortWith(lt: (A, A) ⇒ Boolean): List[A]
</code></pre>
<ul>
<li>方法说明</li>
</ul>
<p>| sortWith方法 | API                  | 说明                                                         |<br>| ———— | ——————– | ———————————————————— |<br>| 参数         | lt: (A, A) ⇒ Boolean | 传入一个比较大小的函数对象<br>接收两个集合类型的元素参数<br>返回两个元素大小，小于返回true，大于返回false |<br>| 返回值       | List[A]              | 返回排序后的列表                                             |</p>
<ul>
<li>方法实操</li>
</ul>
<pre><code class="scala">scala&gt; val list = List(2,3,1,6,4,5)
a: List[Int] = List(2, 3, 1, 6, 4, 5)

//降序
scala&gt; list.sortWith((x,y)=&gt;x&gt;y)
res35: List[Int] = List(6, 5, 4, 3, 2, 1)

//升序
scala&gt; list.sortWith((x,y)=&gt;x&lt;y)
res36: List[Int] = List(1, 2, 3, 4, 5, 6)
</code></pre>
</li>
</ul>
<ul>
<li>16.6 分组 - groupBy</li>
</ul>
<ul>
<li>我们如果要将数据按照分组来进行统计分析，就需要使用到分组方法</li>
<li>groupBy表示按照函数将列表分成不同的组</li>
<li>方法描述</li>
</ul>
<pre><code class="scala">def groupBy[K](f: (A) ⇒ K): Map[K, List[A]]
</code></pre>
<ul>
<li>方法说明</li>
</ul>
<table>
<thead>
<tr>
<th>groupBy方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>泛型</td>
<td>[K]</td>
<td>分组字段的类型</td>
</tr>
<tr>
<td>参数</td>
<td>f: (A) ⇒ K</td>
<td>传入一个函数对象<br>接收集合元素类型的参数<br>返回一个K类型的key，这个key会用来进行分组，相同的key放在一组中</td>
</tr>
<tr>
<td>返回值</td>
<td>Map[K, List[A]]</td>
<td>返回一个映射，K为分组字段，List为这个分组字段对应的一组数据</td>
</tr>
</tbody>
</table>
<ul>
<li>方法实操</li>
</ul>
<pre><code class="scala">scala&gt; val a = List(&quot;张三&quot;-&gt;&quot;男&quot;, &quot;李四&quot;-&gt;&quot;女&quot;, &quot;王五&quot;-&gt;&quot;男&quot;)
a: List[(String, String)] = List((张三,男), (李四,女), (王五,男))

// 按照性别分组
scala&gt; a.groupBy(_._2)
res0: scala.collection.immutable.Map[String,List[(String, String)]] = Map(男 -&gt; List((张三,男), (王五,男)),
女 -&gt; List((李四,女)))

// 将分组后的映射转换为性别/人数元组列表
scala&gt; res0.map(x =&gt; x._1 -&gt; x._2.size)
res3: scala.collection.immutable.Map[String,Int] = Map(男 -&gt; 2, 女 -&gt; 1)
</code></pre>
<ul>
<li>16.7 聚合 - reduce</li>
</ul>
<ul>
<li>reduce表示将列表，传入一个函数进行聚合计算</li>
<li>方法描述</li>
</ul>
<pre><code class="scala">def reduce[A1 &gt;: A](op: (A1, A1) ⇒ A1): A1
</code></pre>
<ul>
<li>方法说明</li>
</ul>
<table>
<thead>
<tr>
<th>reduce方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>泛型</td>
<td>[A1 &gt;: A]</td>
<td>（下界）A1必须是集合元素类型的子类</td>
</tr>
<tr>
<td>参数</td>
<td>op: (A1, A1) ⇒ A1</td>
<td>传入函数对象，用来不断进行聚合操作<br>第一个A1类型参数为：当前聚合后的变量<br>第二个A1类型参数为：当前要进行聚合的元素</td>
</tr>
<tr>
<td>返回值</td>
<td>A1</td>
<td>列表最终聚合为一个元素</td>
</tr>
</tbody>
</table>
<ul>
<li>方法实操</li>
</ul>
<pre><code class="scala">scala&gt; val a = List(1,2,3,4,5,6,7,8,9,10)
a: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala&gt; a.reduce((x,y) =&gt; x + y)
res5: Int = 55

// 第一个下划线表示第一个参数，就是历史的聚合数据结果
// 第二个下划线表示第二个参数，就是当前要聚合的数据元素
scala&gt; a.reduce(_ + _)
res53: Int = 55

// 与reduce一样，从左往右计算
scala&gt; a.reduceLeft(_ + _)
res0: Int = 55

// 从右往左聚合计算
scala&gt; a.reduceRight(_ + _)
res1: Int = 55
</code></pre>
<ul>
<li>16.8 折叠 - fold</li>
</ul>
<ul>
<li>fold与reduce很像，但是多了一个指定初始值参数</li>
<li>方法描述</li>
</ul>
<pre><code class="scala">def fold[A1 &gt;: A](z: A1)(op: (A1, A1) ⇒ A1): A1
</code></pre>
<ul>
<li>方法说明</li>
</ul>
<table>
<thead>
<tr>
<th>reduce方法</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>泛型</td>
<td>[A1 &gt;: A]</td>
<td>（下界）A1必须是集合元素类型的子类</td>
</tr>
<tr>
<td>参数1</td>
<td>z: A1</td>
<td>初始值</td>
</tr>
<tr>
<td>参数2</td>
<td>op: (A1, A1) ⇒ A1</td>
<td>传入函数对象，用来不断进行折叠操作<br>第一个A1类型参数为：当前折叠后的变量<br>第二个A1类型参数为：当前要进行折叠的元素</td>
</tr>
<tr>
<td>返回值</td>
<td>A1</td>
<td>列表最终折叠为一个元素</td>
</tr>
</tbody>
</table>
<ul>
<li>方法实操</li>
</ul>
<pre><code class="scala">//定义一个List集合
scala&gt; val a = List(1,2,3,4,5,6,7,8,9,10)
a: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

//求和
scala&gt; a.sum
res41: Int = 55

//给定一个初始值，，折叠求和
scala&gt; a.fold(0)(_+_)
res42: Int = 55

scala&gt; a.fold(10)(_+_)
res43: Int = 65

//从左往右
scala&gt; a.foldLeft(10)(_+_)
res44: Int = 65

//从右往左
scala&gt; a.foldRight(10)(_+_)
res45: Int = 65


//fold和foldLet效果一致，表示从左往右计算
//foldRight表示从右往左计算

</code></pre>
<h3 id="17-高阶函数"><a href="#17-高阶函数" class="headerlink" title="17. 高阶函数"></a>17. 高阶函数</h3><ul>
<li>使用函数值作为参数，或者返回值为函数值的“函数”和“方法”，均称之为“高阶函数”。</li>
</ul>
<ul>
<li>17.1 函数值作为参数</li>
</ul>
<pre><code class="scala">//定义一个数组
scala&gt; val array=Array(1,2,3,4,5)
array: Array[Int] = Array(1, 2, 3, 4, 5)

//定义一个函数
scala&gt; val func=(x:Int)=&gt;x*10
func: Int =&gt; Int = &lt;function1&gt;

//函数作为参数传递到方法中
scala&gt; array.map(func)
res0: Array[Int] = Array(10, 20, 30, 40, 50)
</code></pre>
<ul>
<li>17.2 匿名函数</li>
</ul>
<pre><code class="scala">//定义一个数组
scala&gt; val array=Array(1,2,3,4,5)
array: Array[Int] = Array(1, 2, 3, 4, 5)

//定义一个没有名称的函数----匿名函数
scala&gt; array.map(x=&gt;x*10)
res1: Array[Int] = Array(10, 20, 30, 40, 50)

</code></pre>
<ul>
<li>17.3 柯里化</li>
</ul>
<ul>
<li>方法可以定义多个参数列表，当使用较少的参数列表调用多参数列表的方法时，会产生一个新的函数，该函数接收剩余的参数列表作为其参数。这被称为柯里化。</li>
</ul>
<pre><code class="scala">def getAddress(a:String):(String,String)=&gt;String={
    (b:String,c:String)=&gt;a+&quot;-&quot;+b+&quot;-&quot;+c
}

scala&gt; val f1=getAddress(&quot;china&quot;)
f1: (String, String) =&gt; String = &lt;function2&gt;

scala&gt; f1(&quot;beijing&quot;,&quot;tiananmen&quot;)
res5: String = china-beijing-tiananmen



//这里就可以这样去定义方法
def getAddress(a:String)(b:String,c:String):String={ 
          a+&quot;-&quot;+b+&quot;-&quot;+c 
}
//调用
scala&gt; getAddress(&quot;china&quot;)(&quot;beijing&quot;,&quot;tiananmen&quot;)
res0: String = china-beijing-tiananmen

//之前学习使用的下面这些操作就是使用到了柯里化
List(1,2,3,4).fold(0)(_+_)
List(1,2,3,4).foldLeft(0)(_+_)
List(1,2,3,4).foldRight(0)(_+_)

</code></pre>
<ul>
<li>17.4 闭包</li>
</ul>
<ul>
<li>函数里面引用外面类成员变量叫作闭包</li>
</ul>
<pre><code class="scala">var factor=10

val f1=(x:Int) =&gt; x*factor


//定义的函数f1，它的返回值是依赖于不在函数作用域的一个变量
//后期必须要要获取到这个变量才能执行
//spark和flink程序的开发中大量的使用到函数，函数的返回值依赖的变量可能都需要进行大量的网络传输获取得到。这里就需要这些变量实现序列化进行网络传输。

</code></pre>
<h3 id="18-scala面向对象编程之类"><a href="#18-scala面向对象编程之类" class="headerlink" title="18. scala面向对象编程之类"></a>18. scala面向对象编程之类</h3><ul>
<li>18.1 类的定义</li>
</ul>
<ul>
<li>scala是支持面向对象的，也有类和对象的概念。<ul>
<li>定义一个Customer类，并添加成员变量/成员方法</li>
<li>添加一个main方法，并创建Customer类的对象，并给对象赋值，打印对象中的成员，调用成员方法</li>
</ul>
</li>
</ul>
<pre><code class="scala">class Customer {
  var name:String = _
  var sex:String = _
  val registerDate:Date = new Date

  def sayHi(msg:String) = {
    println(msg)
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    val customer = new Customer
    //给对象的成员变量赋值
    customer.name = &quot;张三&quot;
    customer.sex = &quot;男&quot;

    println(s&quot;姓名: ${customer.name}, 性别：${customer.sex}, 注册时间: ${customer.registerDate}&quot;)
    //对象调用方法  
    customer.sayHi(&quot;你好!&quot;)
  }
}

</code></pre>
<ul>
<li>说明</li>
</ul>
<pre><code class="html">(1). var name:String = _，  _表示使用默认值进行初始化
   例如：String类型默认值是null，Int类型默认值是0，Boolean类型默认值是false...
(2). val变量不能使用_来进行初始化，因为val是不可变的，所以必须手动指定一个默认值
(3). main方法必须要放在一个scala的object（单例对象）中才能执行

</code></pre>
<ul>
<li>18.2 类的构造器</li>
</ul>
<ul>
<li><p>主构造器</p>
<ul>
<li>主构造器是指在类名的后面跟上一系列参数，例如</li>
</ul>
<pre><code class="scala">class 类名(var/val 参数名:类型 = 默认值, var/val 参数名:类型 = 默认值){
    // 构造代码块
}

</code></pre>
</li>
<li><p>辅助构造器</p>
<ul>
<li>在类中使用this来定义，例如</li>
</ul>
<pre><code class="scala">def this(参数名:类型, 参数名:类型) {
    ...
}
</code></pre>
</li>
<li><p>演示</p>
<pre><code class="scala">class Student(val name:String, val age:Int) {

   val address:String=&quot;beijing&quot; 
  // 定义一个参数的辅助构造器
  def this(name:String) {
    // 第一行必须调用主构造器、其他辅助构造器或者super父类的构造器
    this(name, 20)
  }

  def this(age:Int) {
    this(&quot;某某某&quot;, age)
  }
}

</code></pre>
</li>
</ul>
<h3 id="19-scala面向对象编程之对象"><a href="#19-scala面向对象编程之对象" class="headerlink" title="19.scala面向对象编程之对象"></a>19.scala面向对象编程之对象</h3><ul>
<li>19.1 scala中的object</li>
</ul>
<ul>
<li><p>scala中是没有Java中的静态成员的。如果将来我们需要用到static变量、static方法，就要用到scala中的单例对象object</p>
</li>
<li><p>定义object</p>
<ul>
<li>定义单例对象和定义类很像，就是把class换成object</li>
</ul>
</li>
<li>演示<ul>
<li>定义一个工具类，用来格式化日期时间</li>
</ul>
</li>
</ul>
<pre><code class="scala">object DateUtils {

  // 在object中定义的成员变量，相当于Java中定义一个静态变量
  // 定义一个SimpleDateFormat日期时间格式化对象
  val simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;)

  // 构造代码
  println(&quot;构造代码&quot;)

  // 相当于Java中定义一个静态方法
  def format(date:Date) = simpleDateFormat.format(date)

  // main是一个静态方法，所以必须要写在object中
  def main(args: Array[String]): Unit = {

    println { DateUtils.format(new Date()) };
  }
}

</code></pre>
<ul>
<li>说明</li>
</ul>
<pre><code class="html">(1). 使用object 单例对象名定义一个单例对象，可以用object作为工具类或者存放常量
(2). 在单例对象中定义的变量，类似于Java中的static成员变量
(3). 在单例对象中定义的方法，类似于Java中的static方法
(4). object单例对象的构造代码可以直接写在花括号中
(5). 调用单例对象的方法，直接使用单例对象名.方法名，访问单例对象的成员变量也是使用单例对象名.变量名
(6). 单例对象只能有一个无参的主构造器，不能添加其他参数
</code></pre>
<ul>
<li>19.2 scala中的伴生对象</li>
</ul>
<ul>
<li>在==同一个scala文件，有一个class和object具有同样的名字===，那么就称这个object是class的伴生对象，class是object的伴生类；</li>
<li><p>伴生类和伴生对象的最大特点是，可以相互访问；</p>
</li>
<li><p>演示</p>
</li>
</ul>
<pre><code class="scala">class ClassObject {
  val id = 1
  private var name = &quot;itcast&quot;
  def printName(): Unit ={
    //在Dog类中可以访问伴生对象Dog的私有属性
    println(ClassObject.CONSTANT + name )
  }


}

object ClassObject{
  //伴生对象中的私有属性
  private val CONSTANT = &quot;汪汪汪 : &quot;
  def main(args: Array[String]) {
    val p = new ClassObject
    //访问私有的字段name
    p.name = &quot;123&quot;
    p.printName()
  }
}
</code></pre>
<ul>
<li>说明</li>
</ul>
<pre><code class="html">(1). 伴生类和伴生对象的名字必须是一样的
(2). 伴生类和伴生对象需要在一个scala源文件中
(3). 伴生类和伴生对象可以互相访问private的属性

</code></pre>
<ul>
<li>19.3 scala中object的apply方法</li>
</ul>
<ul>
<li>我们之前使用过这种方式来创建一个Array对象。</li>
</ul>
<pre><code class="scala">// 创建一个Array对象
val a = Array(1,2,3,4)

</code></pre>
<ul>
<li>这种写法非常简便，不需要再写一个new，然后敲一个空格，再写类名。如何直接使用类名来创建对象呢？</li>
<li>查看scala源代码：</li>
</ul>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568196769539.png" alt="1568196769539"></p>
<ul>
<li>答案就是：<strong>==实现伴生对象的apply方法==</strong></li>
<li><p>伴生对象的apply方法用来快速地创建一个伴生类的对象。</p>
</li>
<li><p>演示</p>
</li>
</ul>
<pre><code class="scala">class Person(var name:String, var age:Int) {

  override def toString = s&quot;Person($name, $age)&quot;
}

object Person {
  // 实现apply方法
  // 返回的是伴生类的对象
  def apply(name:String, age:Int): Person = new Person(name, age)

  // apply方法支持重载
  def apply(name:String):Person = new Person(name, 20)

  def apply(age:Int):Person = new Person(&quot;某某某&quot;, age)

  def apply():Person = new Person(&quot;某某某&quot;, 20)
}

object Main2 {
  def main(args: Array[String]): Unit = {
    val p1 = Person(&quot;张三&quot;, 20)
    val p2 = Person(&quot;李四&quot;)
    val p3 = Person(100)
    val p4 = Person()

    println(p1)
    println(p2)
    println(p3)
    println(p4)
  }
}
</code></pre>
<ul>
<li>说明</li>
</ul>
<pre><code class="html">（1）. 当遇到类名(参数1, 参数2...)会自动调用apply方法，在apply方法中来创建对象
（2）. 定义apply时，如果参数列表是空，也不能省略括号()，否则引用的是伴生对象

</code></pre>
<ul>
<li>19.4 scala中object的main方法</li>
</ul>
<ul>
<li><p>scala和Java一样，如果要运行一个程序，必须有一个main方法。</p>
</li>
<li><p>而在Java中main方法是静态的，而在scala中没有静态方法。</p>
</li>
<li><p>==在scala中，这个main方法必须放在一个object中==</p>
<ul>
<li><p>演示1</p>
<pre><code class="scala">object Main1{
  def main(args:Array[String]) = {
    println(&quot;hello, scala&quot;)
  }
}

</code></pre>
</li>
</ul>
</li>
<li><p>==也可以继承自App Trait（特质==），然后将需要编写在main方法中的代码，写在object的构造方法体内。其本质是调用了Trait这个特质中的main方法。</p>
<ul>
<li><p>演示2</p>
<pre><code class="scala">object Main2 extends App {
  println(&quot;hello, scala&quot;)
}

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="20-scala面向对象编程之继承"><a href="#20-scala面向对象编程之继承" class="headerlink" title="20. scala面向对象编程之继承"></a>20. scala面向对象编程之继承</h3><ul>
<li>20.1 继承extends</li>
</ul>
<ul>
<li>scala和Java一样，使用<strong>extends</strong>关键字来实现继承。可以在子类中定义父类中没有的字段和方法，或者重写父类的方法。</li>
<li>==示例1：实现简单继承==</li>
</ul>
<pre><code class="scala">class Person1 {
  var name = &quot;super&quot;

  def getName = this.name
}

class Student1 extends Person1

object Main1 {
  def main(args: Array[String]): Unit = {
    val p1 = new Person1()
    val p2 = new Student1()

    p2.name = &quot;张三&quot;

    println(p2.getName)
  }
}

</code></pre>
<ul>
<li>==示例2：单例对象实现继承==</li>
</ul>
<pre><code class="scala">class Person2 {
  var name = &quot;super&quot;

  def getName = this.name
}

object Student2 extends Person2

object Main2 {
  def main(args: Array[String]): Unit = {
    println(Student2.getName)
  }
}

</code></pre>
<ul>
<li>20.2 override和super</li>
</ul>
<ul>
<li>如果子类要覆盖父类中的一个非抽象方法，必须要使用override关键字</li>
<li>可以使用override关键字来重写一个val字段</li>
<li>可以使用super关键字来访问父类的成员</li>
<li>==示例1：class继承class==</li>
</ul>
<pre><code class="scala">class Person3 {
  val name = &quot;super&quot;

  def getName = name
}

class Student3 extends Person3 {
  // 重写val字段
  override val name: String = &quot;child&quot;

  // 重写getName方法
  override def getName: String = &quot;hello, &quot; + super.getName
}

object Main3 {
  def main(args: Array[String]): Unit = {
    println(new Student3().getName)
  }
}
</code></pre>
<ul>
<li>20.3 isInstanceOf和asInstanceOf</li>
</ul>
<ul>
<li>我们经常要在代码中进行类型的判断和类型的转换。在Java中，我们可以使用instanceof关键字、以及(类型)object来实现，在scala中如何实现呢？</li>
<li>scala中对象提供==isInstanceOf ==和 ==asInstanceOf==方法。<ul>
<li>isInstanceOf判断对象是否为指定类的对象</li>
<li>asInstanceOf将对象转换为指定类型</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Java</th>
<th>Scala</th>
</tr>
</thead>
<tbody>
<tr>
<td>判断对象是否是C类型</td>
<td>obj instanceof C</td>
<td>obj.isInstanceof[C]</td>
</tr>
<tr>
<td>将对象强转成C类型</td>
<td>(C ) obj</td>
<td>obj.asInstanceof[C]</td>
</tr>
<tr>
<td>获取类型为T的class对象</td>
<td>C.class</td>
<td>classOf[C]</td>
</tr>
</tbody>
</table>
<ul>
<li>==示例==</li>
</ul>
<pre><code class="scala">class Person4
class Student4 extends Person4

object Main4 {
  def main(args: Array[String]): Unit = {
    val s1:Person4 = new Student4

    // 判断s1是否为Student4类型
    if(s1.isInstanceOf[Student4]) {
      // 将s1转换为Student3类型
      val s2 =  s1.asInstanceOf[Student4]
      println(s2)
    }

  }
}
</code></pre>
<ul>
<li>20.4 getClass和classOf</li>
</ul>
<ul>
<li><p>isInstanceOf 只能判断出对象是否为指定类以及其子类的对象，而不能精确的判断出，对象就是指定类的对象。如果要求精确地判断出对象就是指定类的对象，那么就只能使用 getClass 和 classOf 。</p>
<ul>
<li><p>对象.getClass可以精确获取对象的类型</p>
</li>
<li><p>classOf[x]可以精确获取类型</p>
</li>
<li>使用==操作符就可以直接比较</li>
</ul>
</li>
<li><p>==示例==</p>
</li>
</ul>
<pre><code class="scala">class Person5
class Student5 extends Person5

object Student5{
  def main(args: Array[String]) {
    val p:Person5=new Student5
    //判断p是否为Person5类的实例
    println(p.isInstanceOf[Person5])//true

    //判断p的类型是否为Person5类
    println(p.getClass == classOf[Person5])//false

    //判断p的类型是否为Student5类
    println(p.getClass == classOf[Student5])//true
  }
}
</code></pre>
<ul>
<li>20.5 访问修饰符</li>
</ul>
<ul>
<li><p>Java中的访问控制，同样适用于scala，可以在成员前面添加private/protected关键字来控制成员的可见性。但在scala中，==<strong>没有public关键字</strong>，任何没有被标为private或protected的成员都是公共的==。</p>
<ul>
<li><p>==<strong>private[this]修饰符</strong>==</p>
<ul>
<li><p>被修饰的成员只能在当前类中被访问。或者可以理解为：<code>只能通过this.来访问</code>（在当前类中访问成员会自动添加this.）。</p>
</li>
<li><p>==示例==</p>
<pre><code class="scala">class Person6 {
  // 只有在当前对象中能够访问
  private[this] var name = &quot;super&quot;

  def getName = this.name    // 正确！

  def sayHelloTo(p:Person6) = {
    println(&quot;hello&quot; + p.name)     // 报错!无法访问
  }
}

object Person6 {
  def showName(p:Person6) = println(p.name)  // 报错!无法访问
}

</code></pre>
</li>
</ul>
</li>
<li><p>==<strong>protected[this]修饰符</strong>==</p>
<ul>
<li><p>==被修饰的成员只能在当前类和当前子类中被访问==。也可以理解为：当前类通过<strong>this.</strong>访问或者子类通过<strong>this.</strong>访问</p>
</li>
<li><p>示例</p>
<pre><code class="scala">class Person7 {
  // 只有在当前类以及继承该类的当前对象中能够访问
  protected[this] var name = &quot;super&quot;

  def getName = {
    // 正确！
    this.name
  }

  def sayHelloTo1(p:Person7) = {
    // 编译错误！无法访问
    println(p.name)
  }
}

object Person7 {
  def sayHelloTo3(p:Person7) = {
    // 编译错误！无法访问
    println(p.name)
  }
}

class Student7 extends Person7 {
  def showName = {
    // 正确！
    println(name)
  }

  def sayHelloTo2(p:Person7) = {
    // 编译错误！无法访问
    println(p.name)
  }
}

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>20.6 调用父类的constructor</li>
</ul>
<ul>
<li>==实例化子类对象，必须要调用父类的构造器==，在scala中，只能在子类的<code>主构造器</code>中调用父类的构造器</li>
<li>示例</li>
</ul>
<pre><code class="scala">class Person8(var name:String){
    println(&quot;name:&quot;+name)
}

// 直接在父类的类名后面调用父类构造器
class Student8(name:String, var clazz:String) extends Person8(name)

object Main8 {
  def main(args: Array[String]): Unit = {
    val s1 = new Student8(&quot;张三&quot;, &quot;三年二班&quot;)
    println(s&quot;${s1.name} - ${s1.clazz}&quot;)
  }
}

</code></pre>
<ul>
<li>20.7 抽象类</li>
</ul>
<ul>
<li>如果类的某个成员在当前类中的定义是不包含完整的，它就是一个<strong>抽象类</strong></li>
<li>不完整定义有两种情况：<ul>
<li>1.方法没有方法体</li>
<li>2.变量没有初始化</li>
</ul>
</li>
<li><p>没有方法体的方法称为<strong>抽象方法</strong>，没有初始化的变量称为<strong>抽象字段</strong>。定义抽象类和Java一样，在类前面加上<strong>abstract</strong>关键字就可以了</p>
</li>
<li><p>==示例==</p>
</li>
</ul>
<pre><code class="scala">abstract class Person9(val name:String) {
  //抽象方法
  def sayHello:String
  def sayBye:String
  //抽象字段  
  val address:String  
}
class Student9(name:String) extends Person9(name){
  //重写抽象方法
  def sayHello: String = &quot;Hello,&quot;+name
  def sayBye: String =&quot;Bye,&quot;+name
  //重写抽象字段
  override val address:String =&quot;beijing &quot;
}
object Main9{
  def main(args: Array[String]) {
    val s = new Student9(&quot;tom&quot;)
    println(s.sayHello)
    println(s.sayBye)
    println(s.address)
  }
}

</code></pre>
<ul>
<li>20.8 匿名内部类</li>
</ul>
<ul>
<li><p>匿名内部类是没有名称的子类，直接用来创建实例对象。Spark的源代码中有大量使用到匿名内部类。</p>
</li>
<li><p>==示例==</p>
</li>
</ul>
<pre><code class="scala">abstract class Person10 {
  //抽象方法  
  def sayHello:Unit
}

object Main10 {
  def main(args: Array[String]): Unit = {
    // 直接用new来创建一个匿名内部类对象
    val p1 = new Person10 {
      override def sayHello: Unit = println(&quot;我是一个匿名内部类&quot;)
    }
    p1.sayHello
  }
}

</code></pre>
<h3 id="21-scala面向对象编程之trait特质"><a href="#21-scala面向对象编程之trait特质" class="headerlink" title="21. scala面向对象编程之trait特质"></a>21. scala面向对象编程之trait特质</h3><ul>
<li>特质是scala中代码复用的基础单元</li>
<li>它可以将方法和字段定义封装起来，然后添加到类中</li>
<li>与类继承不一样的是，类继承要求每个类都只能继承<code>一个</code>超类，而一个类可以添加<code>任意数量</code>的特质。</li>
<li>特质的定义和抽象类的定义很像，但它是使用<code>trait</code>关键字</li>
</ul>
<ul>
<li>21.1 作为接口使用</li>
</ul>
<ul>
<li><p>使用<code>extends</code>来继承trait（scala不论是类还是特质，都是使用extends关键字）</p>
</li>
<li><p>如果要继承多个trait，则使用<code>with</code>关键字</p>
</li>
<li><p>==<strong>示例一：继承单个trait</strong>==</p>
<pre><code class="scala">trait Logger1 {
  // 抽象方法
  def log(msg:String)
}

class ConsoleLogger1 extends Logger1 {
  override def log(msg: String): Unit = println(msg)
}

object LoggerTrait1 {
  def main(args: Array[String]): Unit = {
    val logger = new ConsoleLogger1
    logger.log(&quot;控制台日志: 这是一条Log&quot;)
  }
}
</code></pre>
</li>
</ul>
<ul>
<li><p>==<strong>示例二：继承多个trait</strong>==</p>
<pre><code class="scala">trait Logger2 {
  // 抽象方法
  def log(msg:String)
}

trait MessageSender {
  def send(msg:String)
}

class ConsoleLogger2 extends Logger2 with MessageSender {

  override def log(msg: String): Unit = println(msg)

  override def send(msg: String): Unit = println(s&quot;发送消息:${msg}&quot;)
}

object LoggerTrait2 {
  def main(args: Array[String]): Unit = {
    val logger = new ConsoleLogger2
    logger.log(&quot;控制台日志: 这是一条Log&quot;)
    logger.send(&quot;你好!&quot;)
  }
}
</code></pre>
</li>
</ul>
<ul>
<li>21.2 定义具体的方法</li>
</ul>
<ul>
<li><p>和类一样，trait中还可以定义具体的方法。</p>
</li>
<li><p>==示例==</p>
<pre><code class="scala">trait LoggerDetail {
  // 在trait中定义具体方法
  def log(msg:String) = println(msg)
}

class PersonService extends LoggerDetail {
  def add() = log(&quot;添加用户&quot;)
}

object MethodInTrait {
  def main(args: Array[String]): Unit = {
    val personService = new PersonService
    personService.add()
  }
}

</code></pre>
</li>
</ul>
<ul>
<li>21.3 定义具体方法和抽象方法</li>
</ul>
<ul>
<li><p>在trait中，可以混合使用具体方法和抽象方法</p>
</li>
<li><p>使用具体方法依赖于抽象方法，而抽象方法可以放到继承trait的子类中实现，这种设计方式也称为<strong>模板模式</strong></p>
</li>
<li><p>==示例==</p>
<pre><code class="scala">trait Logger3 {
  // 抽象方法
  def log(msg:String)
  // 具体方法（该方法依赖于抽象方法log
  def info(msg:String) = log(&quot;INFO:&quot; + msg)
  def warn(msg:String) = log(&quot;WARN:&quot; + msg)
  def error(msg:String) = log(&quot;ERROR:&quot; + msg)
}

class ConsoleLogger3 extends Logger3 {
  override def log(msg: String): Unit = println(msg)
}

object LoggerTrait3 {
  def main(args: Array[String]): Unit = {
    val logger3 = new ConsoleLogger3

    logger3.info(&quot;这是一条普通信息&quot;)
    logger3.warn(&quot;这是一条警告信息&quot;)
    logger3.error(&quot;这是一条错误信息&quot;)
  }
}
</code></pre>
</li>
</ul>
<ul>
<li>21.4 定义具体字段和抽象字段</li>
</ul>
<ul>
<li><p>在trait中可以定义具体字段和抽象字段</p>
</li>
<li><p>继承trait的子类自动拥有trait中定义的字段</p>
</li>
<li><p>字段直接被添加到子类中</p>
</li>
<li><p>==示例==</p>
<p>~~~scala<br>trait LoggerEx {<br>  // 具体字段<br>  val sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm”)<br>  val INFO = “信息:” + sdf.format(new Date)<br>  // 抽象字段<br>  val TYPE:String</p>
<p>  // 抽象方法<br>  def log(msg:String)<br>}</p>
<p>class ConsoleLoggerEx extends LoggerEx {<br>  // 实现抽象字段<br>  override val TYPE: String = “控制台”<br>  // 实现抽象方法<br>  override def log(msg:String): Unit = print(s”$TYPE$INFO $msg”)<br>}</p>
<p>object FieldInTrait {<br>  def main(args: Array[String]): Unit = {</p>
<pre><code>val logger = new ConsoleLoggerEx

logger.log(&quot;这是一条消息&quot;)
</code></pre><p>  }<br>}</p>
</li>
</ul>
<pre><code>


- 21.5 实例对象混入trait

* trait还可以混入到`实例对象`中，给对象实例添加额外的行为

* 只有混入了trait的对象才具有trait中的方法，其他的类对象不具有trait中的行为

* 使用with将trait混入到实例对象中

* ==示例==

  ~~~scala
  trait LoggerMix {
    def log(msg:String) = println(msg)
  }

  class UserService

  object FixedInClass {
    def main(args: Array[String]): Unit = {
      // 使用with关键字直接将特质混入到对象中
      val userService = new UserService with LoggerMix

      userService.log(&quot;你好&quot;)
    }
  }

</code></pre><h3 id="22-模式匹配和样例类"><a href="#22-模式匹配和样例类" class="headerlink" title="22. 模式匹配和样例类"></a>22. 模式匹配和样例类</h3><ul>
<li>scala有一个十分强大的模式匹配机制，可以应用到很多场合。<ul>
<li>switch语句</li>
<li>类型查询</li>
<li>以及快速获取数据</li>
</ul>
</li>
<li>并且scala还提供了样例类，对模式匹配进行了优化，可以快速进行匹配。</li>
</ul>
<ul>
<li>22.1 匹配字符串</li>
</ul>
<pre><code class="scala">//todo:匹配字符串
object CaseDemo01 extends App{
  //定义一个数组
  val arr=Array(&quot;hadoop&quot;,&quot;zookeeper&quot;,&quot;spark&quot;,&quot;storm&quot;)

  //随机取数组中的一位，使用Random.nextInt
  val name = arr(Random.nextInt(arr.length))
  println(name)

  name match {
    case &quot;hadoop&quot;     =&gt; println(&quot;大数据分布式存储和计算框架...&quot;)
    case &quot;zookeeper&quot;  =&gt; println(&quot;大数据分布式协调服务框架...&quot;)
    case &quot;spark&quot;      =&gt; println(&quot;大数据分布式内存计算框架...&quot;)
      //表示以上情况都不满足才会走最后一个
    case _            =&gt; println(&quot;我不认识你&quot;)
  }

}

</code></pre>
<ul>
<li>22.2 匹配类型</li>
</ul>
<pre><code class="scala">//todo:匹配类型
object CaseDemo02 extends App{
  //定义一个数组
  val arr=Array(&quot;hello&quot;,1,-2.0,CaseDemo02)

  //随机获取数组中的元素
  val value=arr(Random.nextInt(arr.length))
  println(value)


  value match {
    case x:Int                =&gt; println(&quot;Int=&gt;&quot;+x)
    case y:Double if(y&gt;=0)    =&gt; println(&quot;Double=&gt;&quot;+y)
    case z:String             =&gt; println(&quot;String=&gt;&quot;+z)
    case _                    =&gt; throw new Exception(&quot;not match exception&quot;)
  }

}

</code></pre>
<ul>
<li>22.3 匹配数组</li>
</ul>
<pre><code class="scala">//匹配数组
object CaseDemo03 extends App{

  //匹配数组
  val  arr=Array(1,3,5)
  arr match{
    case Array(1,x,y) =&gt;println(x+&quot;---&quot;+y)
    case Array(1,_*)  =&gt;println(&quot;1...&quot;)
    case Array(0)     =&gt;println(&quot;only 0&quot;)
    case _            =&gt;println(&quot;something else&quot;)

  }
}

</code></pre>
<ul>
<li>22.4 匹配集合</li>
</ul>
<pre><code class="scala">//匹配集合
object CaseDemo04 extends App{

  val list=List(0,3,6)
  list match {
    case 0::Nil        =&gt; println(&quot;only 0&quot;)
    case 0::tail       =&gt; println(&quot;0....&quot;)
    case x::y::z::Nil  =&gt; println(s&quot;x:$x y:$y z:$z&quot;)
    case _             =&gt; println(&quot;something else&quot;)
  }
}    


</code></pre>
<ul>
<li>22.5 匹配元组</li>
</ul>
<pre><code class="scala">//匹配元组
object CaseDemo05 extends App{

  val tuple=(1,3,5)
  tuple match{
    case (1,x,y)    =&gt; println(s&quot;1,$x,$y&quot;)
    case (2,x,y)    =&gt; println(s&quot;$x,$y&quot;)
    case _          =&gt; println(&quot;others...&quot;)
  }
}

</code></pre>
<ul>
<li>22.6 样例类</li>
</ul>
<ul>
<li><p>样例类是一种特殊类，它可以用来快速定义一个用于<strong>保存数据</strong>的类（类似于Java POJO类），==而且它会自动生成apply方法，允许我们快速地创建样例类实例对象==。后面在并发编程和spark、flink这些框架也都会经常使用它。</p>
</li>
<li><p>定义样例类</p>
<ul>
<li><p>语法结构</p>
<pre><code class="scala">case class 样例类名(成员变量名1:类型1, 成员变量名2:类型2 ...)

</code></pre>
</li>
</ul>
</li>
<li><p>==示例==</p>
<pre><code class="scala">// 定义一个样例类
// 样例类有两个成员name、age
case class CasePerson(name:String, age:Int)

// 使用var指定成员变量是可变的
case class CaseStudent(var name:String, var age:Int)

object CaseClassDemo {
  def main(args: Array[String]): Unit = {
    // 1. 使用new创建实例
    val zhagnsan = new CasePerson(&quot;张三&quot;, 20)
    println(zhagnsan)

    // 2. 使用类名直接创建实例
    val lisi = CasePerson(&quot;李四&quot;, 21)
    println(lisi)

    // 3. 样例类默认的成员变量都是val的，除非手动指定变量为var类型
    //lisi.age = 22  // 编译错误！age默认为val类型

    val xiaohong = CaseStudent(&quot;小红&quot;, 23)
    xiaohong.age = 24
    println(xiaohong)
  }
}
</code></pre>
</li>
</ul>
<ul>
<li><p>样例对象</p>
<ul>
<li><p>使用case object可以创建样例对象。样例对象是单例的，而且它<strong>没有主构造器</strong>。样例对象是可序列化的。格式：</p>
<pre><code class="scala">case object 样例对象名
</code></pre>
</li>
<li><p>==示例==</p>
<pre><code class="scala">case class SendMessage(text:String)

// 消息如果没有任何参数，就可以定义为样例对象
case object startTask
case object PauseTask
case object StopTask

</code></pre>
</li>
</ul>
</li>
<li><p>样例类和样例对象结合模式使用</p>
<ul>
<li><p>==示例==</p>
<pre><code class="scala">case class SubmitTask(id: String, name: String)
case class HeartBeat(time: Long)
case object CheckTimeOutTask

object CaseDemo06 extends App{

  val arr = Array(CheckTimeOutTask,
                  HeartBeat(10000), 
                  SubmitTask(&quot;0001&quot;, &quot;task-0001&quot;))

  arr(Random.nextInt(arr.length)) match {

       case SubmitTask(id, name) =&gt; println(s&quot;id=$id, name=$name&quot;)
       case HeartBeat(time) =&gt; println(s&quot;time=$time&quot;)
       case CheckTimeOutTask =&gt; println(&quot;检查超时&quot;)

  }
}

</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li>22.7 Option类型</li>
</ul>
<ul>
<li><p>在Scala中Option类型用样例类来表示可能存在或也可能不存在的值</p>
</li>
<li><p>Option类型有2个子类</p>
<ul>
<li><p>一个是Some</p>
<ul>
<li>Some包装了某个值</li>
</ul>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568271621212.png" alt="1568271621212"></p>
</li>
<li><p>一个是None</p>
<ul>
<li>None表示没有值</li>
</ul>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1568271671144.png" alt="1568271671144"></p>
</li>
</ul>
</li>
<li><p>示例</p>
<p>~~~scala<br>object TestOption {<br>  def main(args: Array[String]) {</p>
<pre><code>val map = Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2)

val value: Option[Int] = map.get(&quot;b&quot;)
val v1 =value match {
  case Some(i) =&gt; i
  case None =&gt; 0
}
println(v1)

//更好的方式
val v2 = map.getOrElse(&quot;c&quot;, 0)
println(v2)
</code></pre><p>  }<br>}</p>
</li>
</ul>
<pre><code>


- 22.8 偏函数

* 被包在花括号内==没有match的一组case语句==是一个偏函数

* 它是PartialFunction[A, B]的一个实例，

  * A代表输入参数类型
  * B代表返回结果类型
  * 可以理解为：偏函数是一个参数和一个返回值的函数。

* ==示例==

  ~~~scala
  object TestPartialFunction {
    // func1是一个输入参数为Int类型，返回值为String类型的偏函数
    val func1: PartialFunction[Int, String] = {
      case 1 =&gt; &quot;一&quot;
      case 2 =&gt; &quot;二&quot;
      case 3 =&gt; &quot;三&quot;
      case _ =&gt; &quot;其他&quot;
    }

    def main(args: Array[String]): Unit = {
      println(func1(1))

      val list=List(1,2,3,4,5,6)

      //使用偏函数操作
      val result=list.filter{
        case x if x &gt;3 =&gt; true
        case _ =&gt; false
      }
      println(result)
    }

  }


</code></pre><h3 id="23-异常处理"><a href="#23-异常处理" class="headerlink" title="23. 异常处理"></a>23. 异常处理</h3><ul>
<li>23.1 异常场景</li>
</ul>
<ul>
<li>来看看下面一段代码</li>
</ul>
<pre><code class="scala">  def main(args: Array[String]): Unit = {
   val i = 10 / 0

    println(&quot;你好！&quot;)
  }

Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero
    at ForDemo$.main(ForDemo.scala:3)
    at ForDemo.main(ForDemo.scala)

</code></pre>
<ul>
<li>执行程序，可以看到scala抛出了异常，而且没有打印出来”你好”。说明程序出现错误后就终止了。那怎么解决该问题呢？</li>
</ul>
<ul>
<li>23.2 捕获异常</li>
</ul>
<ul>
<li><p>在scala中，可以使用异常处理来解决这个问题。</p>
<ul>
<li>在Scala里，借用了==模式匹配的思想来做异常的匹配==</li>
<li>以下为scala中try…catch异常处理的语法格式：</li>
</ul>
<p>~~~scala<br>try {</p>
<pre><code>// 代码
</code></pre><p>}<br>catch {</p>
<pre><code>case ex:异常类型1 =&gt; // 代码
case ex:异常类型2 =&gt; // 代码
</code></pre><p>}<br>finally {</p>
<pre><code>// 代码
</code></pre><p>}</p>
</li>
</ul>
<pre><code>
  * try中的代码是我们编写的业务处理代码
  * 在catch中表示当出现某个异常时，需要执行的代码
  * 在finally中，是不管是否出现异常都会执行的代码

* ==示例==

  ~~~scala
  try {
      val i = 10 / 0

  } catch {
      case ex: Exception =&gt; println(ex.getMessage)
  } finally {
      println(&quot;我始终都会执行!&quot;)
  }
</code></pre><ul>
<li>23.3 抛出异常</li>
</ul>
<ul>
<li><p>我们也可以在一个方法中，抛出异常。语法格式和Java类似，使用throw new Exception…</p>
</li>
<li><p>==示例==</p>
<pre><code class="scala">  def main(args: Array[String]): Unit = {
    throw new Exception(&quot;这是一个异常&quot;)
  }

Exception in thread &quot;main&quot; java.lang.Exception: 这是一个异常
    at ForDemo$.main(ForDemo.scala:3)
    at ForDemo.main(ForDemo.scala)
</code></pre>
</li>
</ul>
<h3 id="24-提取器-Extractor"><a href="#24-提取器-Extractor" class="headerlink" title="24. 提取器(Extractor)"></a>24. 提取器(Extractor)</h3><ul>
<li><p>==提取器是从传递给它的对象中提取出构造该对象的参数==。(回想样例类进行模式匹配提取参数)</p>
</li>
<li><p>scala 提取器是一个带有unapply方法的对象。</p>
<ul>
<li>==unapply方法算是apply方法的反向操作==<ul>
<li>unapply接受一个对象，然后从对象中提取值，提取的值通常是用来构造该对象的值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1552639637165.png" alt="1552639637165"></p>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1552639674932.png" alt="1552639674932"></p>
<ul>
<li>==示例==</li>
</ul>
<pre><code class="scala">class Student {
  var name:String = _   // 姓名
  var age:Int = _       // 年龄

  // 实现一个辅助构造器
  def this(name:String, age:Int) = {
    this()

    this.name = name
    this.age = age
  }
}

object Student {
  def apply(name:String, age:Int): Student = new Student(name, age)

  // 实现一个解构器
  def unapply(arg: Student): Option[(String, Int)] = Some(arg.name, arg.age))
}

object extractor_DEMO {
  def main(args: Array[String]): Unit = {
    val zhangsan = Student(&quot;张三&quot;, 20)

    zhangsan match {
      case Student(name, age) =&gt; println(s&quot;姓名：$name 年龄：$age&quot;)
      case _ =&gt; println(&quot;未匹配&quot;)
    }
  }
}
</code></pre>
<h3 id="25-泛型"><a href="#25-泛型" class="headerlink" title="25. 泛型"></a>25. 泛型</h3><ul>
<li>scala和Java一样，类和特质、方法都可以支持泛型。我们在学习集合的时候，一般都会涉及到泛型。</li>
</ul>
<pre><code class="scala">scala&gt; val list1:List[String] = List(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)
list1: List[String] = List(1, 2, 3)

</code></pre>
<ul>
<li>在scala中，使用方括号来定义类型参数。</li>
</ul>
<ul>
<li>25.1 定义一个泛型方法</li>
</ul>
<ul>
<li><p>不考虑泛型的支持</p>
<pre><code class="scala">  def getMiddle(arr:Array[Int]) = arr(arr.length / 2)

  def main(args: Array[String]): Unit = {
    val arr1 = Array(1,2,3,4,5)

    println(getMiddle(arr1))
  }

</code></pre>
</li>
<li><p>考虑泛型的支持</p>
<pre><code class="scala">  def getMiddle[A](arr:Array[A]) = arr(arr.length / 2)

  def main(args: Array[String]): Unit = {
    val arr1 = Array(1,2,3,4,5)
    val arr2 = Array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;)

    println(getMiddle[Int](arr1))
    println(getMiddle[String](arr2))

    // 简写方式
    println(getMiddle(arr1))
    println(getMiddle(arr2))
  }

</code></pre>
</li>
</ul>
<ul>
<li>25.2 定义一个泛型类</li>
</ul>
<ul>
<li>定义一个Pair类包含2个类型不固定的泛型</li>
<li><p>==示例==</p>
<p>~~~scala<br>// 类名后面的方括号，就表示这个类可以使用两个类型、分别是T和S<br>// 这个名字可以任意取<br>class Pair<a href="val first: T, val second: S">T, S</a></p>
</li>
</ul>
<p>case class People(var name:String, val age:Int)</p>
<p>object Pair {<br>  def main(args: Array[String]): Unit = {</p>
<p>  val p1 = new Pair<a href="&quot;张三&quot;, 10">String, Int</a><br>  val p2 = new Pair<a href="&quot;张三&quot;," title="1988-02-19">String, String</a><br>  val p3 = new Pair<a href="People(&quot;张三&quot;, 20">People, People</a>, People(“李四”, 30))<br>  }<br>}</p>
<pre><code>


### 26. 上下界

* ==在指定泛型类型时，有时需要界定泛型类型的范围，而不是接收任意类型==。比如，要求某个泛型类型，必须是某个类的子类，这样在程序中就可以放心的调用父类的方法，程序才能正常的使用与运行.
* scala的上下边界特性允许泛型类型是某个类的子类，或者是某个类的父类
  * 1、 ==U &gt;: T==
    * 这是类型==下界==的定义，也就是U必须是类型T的父类或者是自己本身。
  * 2、 ==U &lt;: T==
    - 这是类型==上界==的定义，也就是U必须是类型T的子类或者是自己本身。
* ==示例一==

~~~scala
// 类名后面的指定泛型的范围 ----上界
class Pair1[T &lt;: Person, S &lt;:Person](val first: T, val second: S) {
  def chat(msg:String) = println(s&quot;${first.name}对${second.name}说: $msg&quot;)
}

class Person(var name:String, val age:Int)

object Pair1 {
  def main(args: Array[String]): Unit = {

  val p3 = new Pair1[Person,Person](new Person(&quot;张三&quot;, 20), new Person(&quot;李四&quot;, 30))
  p3.chat(&quot;你好啊！&quot;)
  }
}

</code></pre><ul>
<li><p>==示例二==</p>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1552657709922.png" alt="1552657709922"></p>
</li>
</ul>
<pre><code class="scala">//要控制Person只能和Person、Policeman聊天，但是不能和Superman聊天。此时，还需要给泛型添加一个下界。

//上下界
class Pair[T &lt;: Person, S &gt;: Policeman &lt;:Person](val first: T, val second: S) {
  def chat(msg:String) = println(s&quot;${first.name}对${second.name}说: $msg&quot;)
}

class Person(var name:String, val age:Int)
class Policeman(name:String, age:Int) extends Person(name, age)
class Superman(name:String) extends Policeman(name, -1)

object Pair {
  def main(args: Array[String]): Unit = {
    // 编译错误：第二个参数必须是Person的子类（包括本身）、Policeman的父类（包括本身）
   val p3 = new Pair[Person,Superman](new Person(&quot;张三&quot;, 20), new Superman(&quot;李四&quot;))
   p3.chat(&quot;你好啊！&quot;)
  }
}
</code></pre>
<h3 id="27-协变、逆变、非变"><a href="#27-协变、逆变、非变" class="headerlink" title="27. 协变、逆变、非变"></a>27. 协变、逆变、非变</h3><ul>
<li>来一个类型转换的问题</li>
</ul>
<pre><code class="scala">class Pair[T](a:T)

object Pair {
  def main(args: Array[String]): Unit = {
    val p1 = new Pair(&quot;hello&quot;)
    // 编译报错，无法将p1转换为p2
    val p2:Pair[AnyRef] = p1

    println(p2)
  }
}
</code></pre>
<ul>
<li><p>==<strong>协变</strong>==</p>
<pre><code class="html">class Pair[+T]，这种情况是协变。类型B是A的子类型，Pair[B]可以认为是Pair[A]的子类型。这种情况，参数化类型的方向和类型的方向是一致的。

</code></pre>
</li>
<li><p>==<strong>逆变</strong>==</p>
<pre><code class="html">class Pair[-T]，这种情况是逆变。类型B是A的子类型，Pair[A]反过来可以认为是Pair[B]的子类型。这种情况，参数化类型的方向和类型的方向是相反的。

</code></pre>
</li>
<li><p>==<strong>非变</strong>==</p>
<pre><code class="html">class Pair[T]{}，这种情况就是非变（默认），类型B是A的子类型，Pair[A]和Pair[B]没有任何从属关系，这种情况和Java是一样的。

</code></pre>
<p><img src="http://kflys.gitee.io/upic/2020/03/31/uPic/kfly-top/scala学习入门/assets/1558064807949.png" alt="1558064807949"></p>
</li>
<li><p>==示例==</p>
<pre><code class="scala">class Super
class Sub extends Super

//非变
class Temp1[A](title: String)
//协变
class Temp2[+A](title: String)
//逆变
class Temp3[-A](title: String)

object Covariance_demo {
  def main(args: Array[String]): Unit = {
    val a = new Sub()
    // 没有问题，Sub是Super的子类
    val b:Super = a

    // 非变
    val t1:Temp1[Sub] = new Temp1[Sub](&quot;测试&quot;)
    // 报错！默认不允许转换
    // val t2:Temp1[Super] = t1

    // 协变
    val t3:Temp2[Sub] = new Temp2[Sub](&quot;测试&quot;)
    val t4:Temp2[Super] = t3

    // 逆变
    val t5:Temp3[Super] = new Temp3[Super](&quot;测试&quot;)
    val t6:Temp3[Sub] = t5
  }
}

</code></pre>
</li>
<li><p>==总结==</p>
<pre><code class="html">C[+T]：如果A是B的子类，那么C[A]是C[B]的子类。
C[-T]：如果A是B的子类，那么C[B]是C[A]的子类。
C[T]： 无论A和B是什么关系，C[A]和C[B]没有从属关系。

</code></pre>
</li>
</ul>
<h3 id="28-隐式转换和隐式参数"><a href="#28-隐式转换和隐式参数" class="headerlink" title="28. 隐式转换和隐式参数"></a>28. 隐式转换和隐式参数</h3><ul>
<li>28.1 隐式转换</li>
</ul>
<pre><code class="html">    Scala提供的隐式转换和隐式参数功能，是非常有特色的功能。是Java等编程语言所没有的功能。它可以允许你手动指定，将某种类型的对象转换成其他类型的对象或者是给一个类增加方法。通过这些功能，可以实现非常强大、特殊的功能。

</code></pre>
<ul>
<li>隐式转换其核心就是定义一个使用 ==implicit== 关键字修饰的方法 实现把一个原始类转换成目标类，进而可以调用目标类中的方法</li>
</ul>
<ul>
<li>28.2 隐式参数</li>
</ul>
<pre><code class="html">    所谓的隐式参数，指的是在函数或者方法中，定义一个用implicit修饰的参数，
此时Scala会尝试找到一个指定类型的用implicit修饰的参数，即隐式值，并注入参数。

</code></pre>
<ul>
<li>==所有的隐式转换和隐式参数必须定义在一个object中==</li>
</ul>
<ul>
<li>28.3 案例演示</li>
</ul>
<ul>
<li><p>==案例一==</p>
<ul>
<li><strong>让File类具备RichFile类中的read方法</strong></li>
</ul>
<pre><code class="scala">package com.kaikeba.implic_demo

import java.io.File

import scala.io.Source

//todo:隐式转换案例一:让File类具备RichFile类中的read方法

object MyPredef{
  //定义一个隐式转换的方法，实现把File转换成RichFile
  implicit  def file2RichFile(file:File)=new RichFile(file)

}

class RichFile(val file:File){
     //读取数据文件的方法
    def read():String={
       Source.fromFile(file).mkString
    }
}

object RichFile{
  def main(args: Array[String]): Unit = {
     //1、构建一个File对象
          val file = new File(&quot;E:\\aa.txt&quot;)

     //2、手动导入隐式转换
      import MyPredef.file2RichFile

       val data: String = file.read
        println(data)
  }
}

</code></pre>
</li>
</ul>
<ul>
<li><p>==案例二==</p>
<ul>
<li><strong>超人变身</strong></li>
</ul>
<pre><code class="scala">package com.kaikeba.implic_demo

//todo:隐式转换案例二:超人变身
class Man(val name:String)

class SuperMan(val name: String) {
  def heat=print(&quot;超人打怪兽&quot;)

}

object SuperMan{
  //隐式转换方法
  implicit def man2SuperMan(man:Man)=new SuperMan(man.name)

  def main(args: Array[String]) {
      val hero=new Man(&quot;hero&quot;)
      //Man具备了SuperMan的方法
      hero.heat
  }

}

</code></pre>
</li>
</ul>
<ul>
<li><p>==案例三==</p>
<ul>
<li><strong>一个类隐式转换成具有相同方法的多个类</strong></li>
</ul>
<pre><code class="scala">package com.kaikeba.implic_demo

//todo:隐式转换案例三（一个类隐式转换成具有相同方法的多个类）

class C
class A(c:C) {
    def readBook(): Unit ={
      println(&quot;A说：好书好书...&quot;)
    }
}

class B(c:C){
  def readBook(): Unit ={
    println(&quot;B说：看不懂...&quot;)
  }
  def writeBook(): Unit ={
    println(&quot;B说：不会写...&quot;)
  }
}

object AB{

  //创建一个类转换为2个类的隐式转换
  implicit def C2A(c:C)=new A(c)
  implicit def C2B(c:C)=new B(c)
}

object B{
  def main(args: Array[String]) {
    //导包
    //1. import AB._ 会将AB类下的所有隐式转换导进来
    //2. import AB.C2A 只导入C类到A类的的隐式转换方法
    //3. import AB.C2B 只导入C类到B类的的隐式转换方法
    import AB._
    val c=new C

    //由于A类与B类中都有readBook()，只能导入其中一个，否则调用共同方法时代码报错
     //c.readBook()

    //C类可以执行B类中的writeBook()
    c.writeBook()

  }
}

</code></pre>
</li>
</ul>
<ul>
<li><p>==案例四==</p>
<ul>
<li><strong>员工领取薪水</strong></li>
</ul>
<p>~~~scala<br>package cn.itcast.implic_demo</p>
<p>//todo:隐式参数案例四:员工领取薪水</p>
<p>object Company{<br>  //在object中定义隐式值    注意：同一类型的隐式值只允许出现一次，否则会报错<br>  implicit  val xxx=”zhangsan”<br>  implicit  val yyy=10000.00</p>
<p>  //implicit  val zzz=”lisi”</p>
<p>}</p>
<p>class Boss {<br>  //定义一个用implicit修饰的参数 类型为String<br>  //注意参数匹配的类型   它需要的是String类型的隐式值<br>  def callName(implicit name:String):String={</p>
<pre><code>name+&quot; is coming !&quot;
</code></pre><p>  }</p>
<p>  //定义一个用implicit修饰的参数，类型为Double<br>  //注意参数匹配的类型    它需要的是Double类型的隐式值<br>  def getMoney(implicit money:Double):String={</p>
<pre><code>&quot; 当月薪水：&quot;+money
</code></pre><p>  }</p>
</li>
</ul>
<p>  }<br>  match<br>  object Boss extends App{<br>    //使用import导入定义好的隐式值，注意：必须先加载否则会报错<br>    import Company.xxx<br>    import Company.yyy</p>
<pre><code>val boss =new Boss
println(boss.callName+boss.getMoney)
</code></pre><p>  }</p>
<p>  ~~~</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://blog.sev7e0.site/">大数据施工现场</a></span>
        <span>/</span>
        
        <span><a href="https://wangchujiang.com/linux-command/">linux命令</a></span>
        <span>/</span>
        
        <span><a href="http://redisdoc.com/">Redis命令</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/orchid-ding">github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
