(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{583:function(a,s,t){"use strict";t.r(s);var e=t(19),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"rdd特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdd特征"}},[a._v("#")]),a._v(" RDD特征")]),a._v(" "),t("ul",[t("li",[a._v("RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合.\n"),t("ul",[t("li",[t("strong",[a._v("Dataset")]),a._v(":          就是一个集合，存储很多数据.")]),a._v(" "),t("li",[t("strong",[a._v("Distributed")]),a._v("：它内部的元素进行了分布式存储，方便于后期进行分布式计算.")]),a._v(" "),t("li",[t("strong",[a._v("Resilient")]),a._v("：     表示弹性，rdd的数据是可以保存在内存或者是磁盘中.")])])])]),a._v(" "),t("h3",{attrs:{id:"_1-a-list-of-partitions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-a-list-of-partitions"}},[a._v("#")]),a._v(" （1）A list of partitions")]),a._v(" "),t("ul",[t("li",[a._v("一个分区（Partition）列表，数据集的基本组成单位。")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('\t这里表示一个rdd有很多分区，每一个分区内部是包含了该rdd的部分数据，\nspark中任务是以task线程的方式运行， 一个分区就对应一个task线程。\n\n\t用户可以在创建RDD时指定RDD的分区个数，如果没有指定，那么就会采用默认值。\n    val rdd=sparkContext.textFile("/words.txt")\n    如果该文件的block块个数小于等于2，这里生产的RDD分区数就为2\n    如果该文件的block块个数大于2，这里生产的RDD分区数就与block块个数保持一致\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br")])]),t("h3",{attrs:{id:"_2-a-function-for-computing-each-split"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-a-function-for-computing-each-split"}},[a._v("#")]),a._v(" （2）A function for computing each split")]),a._v(" "),t("ul",[t("li",[a._v("一个计算每个分区的函数")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\tSpark中RDD的计算是以分区为单位的，每个RDD都会实现compute计算函数以达到这个目的.\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h3",{attrs:{id:"_3-a-list-of-dependencies-on-other-rdds"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-a-list-of-dependencies-on-other-rdds"}},[a._v("#")]),a._v(" （3）A list of dependencies on other RDDs")]),a._v(" "),t("ul",[t("li",[a._v("一个rdd会依赖于其他多个rdd")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  这里就涉及到rdd与rdd之间的依赖关系，spark任务的容错机制就是根据这个特性（血统）而来。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h3",{attrs:{id:"_4-optionally"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-optionally"}},[a._v("#")]),a._v(" （4）Optionally")]),a._v(" "),t("ul",[t("li",[a._v("a Partitioner for key-value RDDs e.g. to say that the RDD is hash-partitioned")]),a._v(" "),t("li",[a._v("一个Partitioner，即RDD的分区函数（可选项）")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("当前Spark中实现了两种类型的分区函数，\n一个是基于哈希的HashPartitioner，(key.hashcode % 分区数= 分区号)\n另外一个是基于范围的RangePartitioner。\n只有对于key-value的RDD,并且产生shuffle，才会有Partitioner，\n\n非key-value的RDD的Parititioner的值是None。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("h3",{attrs:{id:"_5-optionally"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-optionally"}},[a._v("#")]),a._v(" （5）Optionally")]),a._v(" "),t("ul",[t("li",[a._v("a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)")]),a._v(" "),t("li",[a._v("一个列表，存储每个Partition的优先位置(可选项)")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("这里涉及到数据的本地性，数据块位置最优。\nspark任务在调度的时候会优先考虑存有数据的节点开启计算任务，减少数据的网络传输，提升计算效率。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h3",{attrs:{id:"流程分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流程分析"}},[a._v("#")]),a._v(" 流程分析")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/kflys/uPic/raw/master/uPic/1612261065394-2f93fa32-0b72-45c6-9d66-55ef69f4d57e.png",alt:"img"}})]),a._v(" "),t("h2",{attrs:{id:"rdd的算子分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdd的算子分类"}},[a._v("#")]),a._v(" RDD的算子分类")]),a._v(" "),t("h3",{attrs:{id:"_1、transformation-转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、transformation-转换"}},[a._v("#")]),a._v(" 1、transformation（转换）")]),a._v(" "),t("ul",[t("li",[a._v("根据已经存在的rdd转换生成一个新的rdd,  它是延迟加载，它不会立即执行")]),a._v(" "),t("li",[a._v("例如: map / flatMap / reduceByKey 等")])]),a._v(" "),t("h3",{attrs:{id:"_2、action-动作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、action-动作"}},[a._v("#")]),a._v(" 2、action (动作)")]),a._v(" "),t("ul",[t("li",[a._v("它会真正触发任务的运行,将rdd的计算的结果数据返回给Driver端，或者是保存结果数据到外部存储介质中")]),a._v(" "),t("li",[a._v("例如: collect / saveAsTextFile 等")])]),a._v(" "),t("h2",{attrs:{id:"rdd的依赖关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdd的依赖关系"}},[a._v("#")]),a._v(" RDD的依赖关系")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/kflys/uPic/raw/master/uPic/1612261065396-afef817a-06c4-41ba-b033-48f6a819b8cc.png",alt:"img"}})]),a._v(" "),t("ul",[t("li",[a._v("RDD和它依赖的父RDD的关系有两种不同的类型,窄依赖（narrow dependency）和宽依赖（wide dependency）")])]),a._v(" "),t("h3",{attrs:{id:"窄依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#窄依赖"}},[a._v("#")]),a._v(" 窄依赖")]),a._v(" "),t("p",[a._v("窄依赖指的是每一个父RDD的Partition最多被子RDD的一个Partition使用。窄依赖我们形象的比喻为独生子女")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("哪些算子操作是窄依赖：\n\tmap/flatMap/filter/union等等\n\t\n\t所有的窄依赖不会产生shuffle\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("h3",{attrs:{id:"宽依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#宽依赖"}},[a._v("#")]),a._v(" 宽依赖")]),a._v(" "),t("p",[a._v("宽依赖指的是多个子RDD的Partition会依赖同一个父RDD的Partition。宽依赖我们形象的比喻为超生")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("哪些算子操作是宽依赖：\n\treduceByKey/sortByKey/groupBy/groupByKey/join等等\n\t\n\t所有的宽依赖会产生shuffle\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("h3",{attrs:{id:"补充说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#补充说明"}},[a._v("#")]),a._v(" 补充说明")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("由上图可知，join分为宽依赖和窄依赖，如果RDD有相同的partitioner，那么将不会引起shuffle，这种join是窄依赖，反之就是宽依赖\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h2",{attrs:{id:"rdd-lineage-血统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdd-lineage-血统"}},[a._v("#")]),a._v(" RDD lineage（血统）")]),a._v(" "),t("ul",[t("li",[a._v("RDD只支持粗粒度转换\n"),t("ul",[t("li",[a._v("即只记录单个块上执行的单个操作。")])])]),a._v(" "),t("li",[a._v("将创建RDD的一系列Lineage（即血统）记录下来，以便恢复丢失的分区")]),a._v(" "),t("li",[a._v("RDD的Lineage会记录RDD的元数据信息和转换行为，lineage保存了RDD的依赖关系，当该RDD的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。")])]),a._v(" "),t("h2",{attrs:{id:"rdd的缓存机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdd的缓存机制"}},[a._v("#")]),a._v(" RDD的缓存机制")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\t可以把一个rdd的数据缓存起来，后续有其他的job需要用到该rdd的结果数据，可以直接从缓存中获取得到，避免了重复计算。缓存是加快后续对该数据的访问操作。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h3",{attrs:{id:"rdd通过persist方法或cache方法可以将前面的计算结果缓存。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdd通过persist方法或cache方法可以将前面的计算结果缓存。"}},[a._v("#")]),a._v(" RDD通过persist方法或cache方法可以将前面的计算结果缓存。")]),a._v(" "),t("ul",[t("li",[a._v("并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/kflys/uPic/raw/master/uPic/1612261065398-095ded56-2cc0-4e7b-bc47-5bec60e95d0f.png",alt:"img"}})]),a._v(" "),t("ul",[t("li",[a._v("cache最终也是调用了persist方法，默认的存储级别都是仅在内存存储一份，Spark的存储级别还有好多种，存储级别在object StorageLevel中定义的。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/kflys/uPic/raw/master/uPic/1612261065410-bc7120cb-b2ed-4540-ba67-f93286ff06ae.png",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"使用演示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用演示"}},[a._v("#")]),a._v(" 使用演示")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('val rdd1=sc.textFile("/words.txt")\nval rdd2=rdd1.flatMap(_.split(" "))\nval rdd3=rdd2.cache\nrdd3.collect\n\nval rdd4=rdd3.map((_,1))\nval rdd5=rdd4.persist(缓存级别)\nrdd5.collect\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br")])]),t("h3",{attrs:{id:"cache和persist区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache和persist区别"}},[a._v("#")]),a._v(" cache和persist区别")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\t对RDD设置缓存成可以调用rdd的2个方法： 一个是cache，一个是persist\n调用上面2个方法都可以对rdd的数据设置缓存，但不是立即就触发缓存执行，后面需要有action，才会触发缓存的执行。\n\ncache方法和persist方法区别：\n    cache:   默认是把数据缓存在内存中，其本质就是调用persist方法；\n    persist：可以把数据缓存在内存或者是磁盘，有丰富的缓存级别，这些缓存级别都被定义在StorageLevel这个object中。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("h3",{attrs:{id:"清除缓存数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#清除缓存数据"}},[a._v("#")]),a._v(" 清除缓存数据")]),a._v(" "),t("h4",{attrs:{id:"_1、自动清除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、自动清除"}},[a._v("#")]),a._v(" 1、自动清除")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("一个application应用程序结束之后，对应的缓存数据也就自动清除\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h4",{attrs:{id:"_2、手动清除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、手动清除"}},[a._v("#")]),a._v(" 2、手动清除")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("调用rdd的unpersist方法\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h2",{attrs:{id:"rdd的checkpoint机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdd的checkpoint机制"}},[a._v("#")]),a._v(" RDD的checkpoint机制")]),a._v(" "),t("ul",[t("li",[a._v("我们可以对rdd的数据进行缓存，保存在内存或者是磁盘中。\n"),t("ul",[t("li",[a._v("后续就可以直接从内存或者磁盘中获取得到，但是它们不是特别安全。")]),a._v(" "),t("li",[t("strong",[a._v("cache")])])])])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("它是直接把数据保存在内存中，后续操作起来速度比较快，直接从内存中获取得到。但这种方式很不安全，由于服务器挂掉或者是进程终止，会导致数据的丢失。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("ul",[t("li",[t("strong",[a._v("persist")])])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("它可以把数据保存在本地磁盘中，后续可以从磁盘中获取得到该数据，但它也不是特别安全，由于系统管理员一些误操作删除了，或者是磁盘损坏，也有可能导致数据的丢失。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("ul",[t("li",[t("strong",[a._v("checkpoint")]),a._v("（检查点）")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("它是提供了一种相对而言更加可靠的数据持久化方式。它是把数据保存在分布式文件系统，\n比如HDFS上。这里就是利用了HDFS高可用性，高容错性（多副本）来最大程度保证数据的安全性。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h3",{attrs:{id:"如何设置checkpoint"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何设置checkpoint"}},[a._v("#")]),a._v(" 如何设置checkpoint")]),a._v(" "),t("ul",[t("li",[a._v("1、在hdfs上设置一个checkpoint目录")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('sc.setCheckpointDir("hdfs://node01:8020/checkpoint")\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("ul",[t("li",[a._v("2、对需要做checkpoint操作的rdd调用checkpoint方法")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('val rdd1=sc.textFile("/words.txt")\nrdd1.checkpoint\nval rdd2=rdd1.flatMap(_.split(" "))\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("ul",[t("li",[a._v("3、最后需要有一个action操作去触发任务的运行")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("rdd2.collect\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h3",{attrs:{id:"cache、persist、checkpoint三者区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache、persist、checkpoint三者区别"}},[a._v("#")]),a._v(" cache、persist、checkpoint三者区别")]),a._v(" "),t("h4",{attrs:{id:"cache和persist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache和persist"}},[a._v("#")]),a._v(" cache和persist")]),a._v(" "),t("ul",[t("li",[a._v("cache默认数据缓存在内存中")]),a._v(" "),t("li",[a._v("persist可以把数据保存在内存或者磁盘中")]),a._v(" "),t("li",[a._v("后续要触发 cache 和 persist 持久化操作，需要有一个action操作")]),a._v(" "),t("li",[a._v("它不会开启其他新的任务，一个action操作就对应一个job")]),a._v(" "),t("li",[a._v("它不会改变rdd的依赖关系，程序运行完成后对应的缓存数据就自动消失")])]),a._v(" "),t("h4",{attrs:{id:"checkpoint"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#checkpoint"}},[a._v("#")]),a._v(" checkpoint")]),a._v(" "),t("ul",[t("li",[a._v("可以把数据持久化写入到hdfs上")]),a._v(" "),t("li",[a._v("后续要触发checkpoint持久化操作，需要有一个action操作，后续会开启新的job执行checkpoint操作")]),a._v(" "),t("li",[a._v("它会改变rdd的依赖关系，后续数据丢失了不能够在通过血统进行数据的恢复。")]),a._v(" "),t("li",[a._v("程序运行完成后对应的checkpoint数据就不会消失")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('   sc.setCheckpointDir("/checkpoint")\n   val rdd1=sc.textFile("/words.txt")\n   val rdd2=rdd1.cache\n   rdd2.checkpoint\n   val rdd3=rdd2.flatMap(_.split(" "))\n   rdd3.collect\n   \n   checkpoint操作要执行需要有一个action操作，一个action操作对应后续的一个job。该job执行完成之后，它会再次单独开启另外一个job来执行 rdd1.checkpoint操作。\n   \n   对checkpoint在使用的时候进行优化，在调用checkpoint操作之前，可以先来做一个cache操作，缓存对应rdd的结果数据，后续就可以直接从cache中获取到rdd的数据写入到指定checkpoint目录中\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('   sc.setCheckpointDir("/checkpoint")\n   val rdd1=sc.textFile("/words.txt")\n   val rdd2=rdd1.cache\n   rdd2.checkpoint\n   val rdd3=rdd2.flatMap(_.split(" "))\n   rdd3.collect\n   \n   checkpoint操作要执行需要有一个action操作，一个action操作对应后续的一个job。该job执行完成之后，它会再次单独开启另外一个job来执行 rdd1.checkpoint操作。\n   \n   对checkpoint在使用的时候进行优化，在调用checkpoint操作之前，可以先来做一个cache操作，缓存对应rdd的结果数据，后续就可以直接从cache中获取到rdd的数据写入到指定checkpoint目录中\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("h2",{attrs:{id:"dag有向无环图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dag有向无环图"}},[a._v("#")]),a._v(" DAG有向无环图")]),a._v(" "),t("h3",{attrs:{id:"gag生成有向无环图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gag生成有向无环图"}},[a._v("#")]),a._v(" GAG生成有向无环图")]),a._v(" "),t("ul",[t("li",[a._v("DAG(Directed Acyclic Graph) 叫做有向无环图（有方向,无闭环,代表着数据的流向），原始的RDD通过一系列的转换就形成了DAG。")]),a._v(" "),t("li",[a._v("下图是基于单词统计逻辑得到的DAG有向无环图")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/kflys/uPic/raw/master/uPic/1612261065408-906ba9f6-5cac-4dde-a3b2-46c089dd5bae.png",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"dag划分stage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dag划分stage"}},[a._v("#")]),a._v(" DAG划分stage")]),a._v(" "),t("h4",{attrs:{id:"stage是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stage是什么"}},[a._v("#")]),a._v(" stage是什么")]),a._v(" "),t("ul",[t("li",[a._v("一个Job会被拆分为多组Task，每组任务被称为一个stage")]),a._v(" "),t("li",[a._v("stage表示不同的调度阶段，一个spark job会对应产生很多个stage\n"),t("ul",[t("li",[a._v("ShuffleMapStage")])])])]),a._v(" "),t("blockquote",[t("p",[a._v("最后一个shuffle之前的所有变换的Stage叫ShuffleMapStage,\n它对应的task是shuffleMapTask")])]),a._v(" "),t("ul",[t("li",[a._v("ResultStage")])]),a._v(" "),t("blockquote",[t("p",[a._v("最后一个shuffle之后操作的Stage叫ResultStage，它是最后一个Stage。\n它对应的task是ResultTask")])]),a._v(" "),t("h4",{attrs:{id:"为什么要划分stage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要划分stage"}},[a._v("#")]),a._v(" 为什么要划分stage")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("根据RDD之间依赖关系的不同将DAG划分成不同的Stage(调度阶段)\n对于窄依赖，partition的转换处理在一个Stage中完成计算\n对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算，\n\n由于划分完stage之后，在同一个stage中只有窄依赖，没有宽依赖，可以实现流水线计算，\nstage中的每一个分区对应一个task，在同一个stage中就有很多可以并行运行的task。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("h4",{attrs:{id:"如何划分stage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何划分stage"}},[a._v("#")]),a._v(" 如何划分stage")]),a._v(" "),t("ul",[t("li",[a._v("划分stage的依据就是宽依赖")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("(1) 首先根据rdd的算子操作顺序生成DAG有向无环图，接下里从最后一个rdd往前推，创建一个新的stage，把该rdd加入到该stage中，它是最后一个stage。\n\n(2) 在往前推的过程中运行遇到了窄依赖就把该rdd加入到本stage中，如果遇到了宽依赖，就从宽依赖切开，那么最后一个stage也就结束了。\n\n(3) 重新创建一个新的stage，按照第二个步骤继续往前推，一直到最开始的rdd，整个划分stage也就结束了\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("p",[t("img",{attrs:{src:"https://gitee.com/kflys/uPic/raw/master/uPic/1612261065398-24c2958d-e6ab-4291-983a-aa5dde9c52ac.png",alt:"img"}})]),a._v(" "),t("h4",{attrs:{id:"stage与stage之间的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stage与stage之间的关系"}},[a._v("#")]),a._v(" stage与stage之间的关系")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\t划分完stage之后，每一个stage中有很多可以并行运行的task，后期把每一个stage中的task封装在一个taskSet集合中，最后把一个一个的taskSet集合提交到worker节点上的executor进程中运行。\n\nrdd与rdd之间存在依赖关系，stage与stage之前也存在依赖关系，前面stage中的task先运行，运行完成了再运行后面stage中的task，也就是说后面stage中的task输入数据是前面stage中task的输出结果数据。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("p",[t("img",{attrs:{src:"https://gitee.com/kflys/uPic/raw/master/uPic/1612261065409-8f70d5d1-cff0-4f72-9605-509a4eb81ddd.png",alt:"img"}})])])}),[],!1,null,null,null);s.default=r.exports}}]);